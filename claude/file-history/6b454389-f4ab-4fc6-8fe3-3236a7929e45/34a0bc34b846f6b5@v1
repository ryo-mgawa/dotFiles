import { SHIPMENT_EVENT_TYPE } from '@app/rdb/db/models/shipmentEvent/type';
import { SHIPMENT_STATUS } from '@app/rdb/db/models/shipmentStatus/status';
import { INestApplication } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';
import { ShipmentRepository } from '../../../../data/repository/shipmentRepository';
import { AddShipmentEventsPresenterInterface } from '../../../../interface/presenter/addShipmentEventsPresenterInterface';
import { ShipmentEventCreator } from '../../../service/creator/shipmentEventCreator';
import { AddShipmentEventsUseCase } from '../addShipmentEventsUseCase';
import { Input } from '../types';

jest.mock('@app/requestContext/requestContext', () => {
  return {
    RequestContext: class DummyRequestContext {
      public static get() {
        return {
          user: {
            organizationId: 'organizationId',
            userId: 'userId',
            role: 'manager',
          },
        };
      }
      public static start(_, next) {
        next();
      }
    },
  };
});

describe('AddShipmentEventsUseCase', () => {
  let addShipmentEventsUseCase: AddShipmentEventsUseCase;
  let moduleRef: TestingModule;
  let app: INestApplication;
  let mockCreator: { execute: jest.Mock };
  let mockRepository: { saveEvents: jest.Mock };
  let mockPresenter: { output: jest.Mock };

  describe('execute', () => {
    it('単一のイベントが正しく保存される', async () => {
      await createTestingModule();

      const executedAt = new Date('2025-11-10T10:00:00Z');
      const input: Input = {
        events: [
          {
            shipmentId: 'shipment-1',
            type: SHIPMENT_EVENT_TYPE.STORE,
            originalSpotId: 'spot-1',
            geocode: { x: 139.7671, y: 35.6812 },
            executedAt,
          },
        ],
      };

      await addShipmentEventsUseCase.execute(input, 'user-1');

      expect(mockCreator.execute).toHaveBeenCalledWith(input.events, 'user-1');
      expect(mockRepository.saveEvents).toHaveBeenCalledWith(
        [
          {
            id: 'event-id-1',
            shipmentId: 'shipment-1',
            type: SHIPMENT_EVENT_TYPE.STORE,
            originalSpotId: 'spot-1',
            geocode: { x: 139.7671, y: 35.6812 },
            updateBy: 'user-1',
            executedAt,
          },
        ],
        [
          {
            shipmentId: 'shipment-1',
            status: SHIPMENT_STATUS.IN_STORAGE,
            executedAt,
          },
        ]
      );
      expect(mockPresenter.output).toHaveBeenCalled();
    });

    it('複数のイベントが一括保存される', async () => {
      await createTestingModule();

      const executedAt1 = new Date('2025-11-10T10:00:00Z');
      const executedAt2 = new Date('2025-11-10T11:00:00Z');

      const input: Input = {
        events: [
          {
            shipmentId: 'shipment-1',
            type: SHIPMENT_EVENT_TYPE.STORE,
            originalSpotId: 'spot-1',
            executedAt: executedAt1,
          },
          {
            shipmentId: 'shipment-2',
            type: SHIPMENT_EVENT_TYPE.COMPLETE,
            originalSpotId: 'spot-2',
            executedAt: executedAt2,
          },
        ],
      };

      await addShipmentEventsUseCase.execute(input, 'user-1');

      expect(mockRepository.saveEvents).toHaveBeenCalledWith(
        expect.arrayContaining([
          expect.objectContaining({
            id: expect.any(String),
            shipmentId: 'shipment-1',
            type: SHIPMENT_EVENT_TYPE.STORE,
            updateBy: 'user-1',
          }),
          expect.objectContaining({
            id: expect.any(String),
            shipmentId: 'shipment-2',
            type: SHIPMENT_EVENT_TYPE.COMPLETE,
            updateBy: 'user-1',
          }),
        ]),
        expect.arrayContaining([
          expect.objectContaining({
            shipmentId: 'shipment-1',
            status: SHIPMENT_STATUS.IN_STORAGE,
          }),
          expect.objectContaining({
            shipmentId: 'shipment-2',
            status: SHIPMENT_STATUS.COMPLETED,
          }),
        ])
      );
      expect(mockPresenter.output).toHaveBeenCalled();
    });

    it('Storeイベント → InStorage状態に変換される', async () => {
      await createTestingModule();

      const executedAt = new Date('2025-11-10T10:00:00Z');
      const input: Input = {
        events: [
          {
            shipmentId: 'shipment-1',
            type: SHIPMENT_EVENT_TYPE.STORE,
            originalSpotId: 'spot-1',
            executedAt,
          },
        ],
      };

      await addShipmentEventsUseCase.execute(input, 'user-1');

      expect(mockRepository.saveEvents).toHaveBeenCalledWith(
        expect.any(Array),
        expect.arrayContaining([
          expect.objectContaining({
            status: SHIPMENT_STATUS.IN_STORAGE,
          }),
        ])
      );
    });

    it('ToReadyイベント → Ready状態に変換される', async () => {
      await createTestingModule();

      const executedAt = new Date('2025-11-10T10:00:00Z');
      const input: Input = {
        events: [
          {
            shipmentId: 'shipment-1',
            type: SHIPMENT_EVENT_TYPE.TO_READY,
            originalSpotId: 'spot-1',
            executedAt,
          },
        ],
      };

      await addShipmentEventsUseCase.execute(input, 'user-1');

      expect(mockRepository.saveEvents).toHaveBeenCalledWith(
        expect.any(Array),
        expect.arrayContaining([
          expect.objectContaining({
            status: SHIPMENT_STATUS.READY,
          }),
        ])
      );
    });

    it('InTransitイベント → InTransit状態に変換される', async () => {
      await createTestingModule();

      const executedAt = new Date('2025-11-10T10:00:00Z');
      const input: Input = {
        events: [
          {
            shipmentId: 'shipment-1',
            type: SHIPMENT_EVENT_TYPE.IN_TRANSIT,
            originalSpotId: 'spot-1',
            executedAt,
          },
        ],
      };

      await addShipmentEventsUseCase.execute(input, 'user-1');

      expect(mockRepository.saveEvents).toHaveBeenCalledWith(
        expect.any(Array),
        expect.arrayContaining([
          expect.objectContaining({
            status: SHIPMENT_STATUS.IN_TRANSIT,
          }),
        ])
      );
    });

    it('Completeイベント → Completed状態に変換される', async () => {
      await createTestingModule();

      const executedAt = new Date('2025-11-10T10:00:00Z');
      const input: Input = {
        events: [
          {
            shipmentId: 'shipment-1',
            type: SHIPMENT_EVENT_TYPE.COMPLETE,
            originalSpotId: 'spot-1',
            executedAt,
          },
        ],
      };

      await addShipmentEventsUseCase.execute(input, 'user-1');

      expect(mockRepository.saveEvents).toHaveBeenCalledWith(
        expect.any(Array),
        expect.arrayContaining([
          expect.objectContaining({
            status: SHIPMENT_STATUS.COMPLETED,
          }),
        ])
      );
    });

    it('Cancelイベント → Canceled状態に変換される', async () => {
      await createTestingModule();

      const executedAt = new Date('2025-11-10T10:00:00Z');
      const input: Input = {
        events: [
          {
            shipmentId: 'shipment-1',
            type: SHIPMENT_EVENT_TYPE.CANCEL,
            originalSpotId: 'spot-1',
            executedAt,
          },
        ],
      };

      await addShipmentEventsUseCase.execute(input, 'user-1');

      expect(mockRepository.saveEvents).toHaveBeenCalledWith(
        expect.any(Array),
        expect.arrayContaining([
          expect.objectContaining({
            status: SHIPMENT_STATUS.CANCELED,
          }),
        ])
      );
    });
  });

  const createTestingModule = async () => {
    mockCreator = {
      execute: jest.fn().mockImplementation((events, updateBy) => {
        return events.map((e, index) => ({
          id: `event-id-${index + 1}`,
          shipmentId: e.shipmentId,
          type: e.type,
          originalSpotId: e.originalSpotId,
          geocode: e.geocode ?? null,
          updateBy,
          executedAt: e.executedAt,
        }));
      }),
    };

    mockRepository = {
      saveEvents: jest.fn().mockResolvedValue(undefined),
    };

    mockPresenter = {
      output: jest.fn(),
    };

    moduleRef = await Test.createTestingModule({
      imports: [],
      providers: [
        AddShipmentEventsUseCase,
        {
          provide: ShipmentEventCreator,
          useValue: mockCreator,
        },
        {
          provide: ShipmentRepository,
          useValue: mockRepository,
        },
        {
          provide: 'AddShipmentEventsPresenter',
          useValue: mockPresenter,
        },
      ],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    addShipmentEventsUseCase = moduleRef.get<AddShipmentEventsUseCase>(
      AddShipmentEventsUseCase,
    );
  };

  afterEach(async () => {
    if (app) {
      await app.close();
    }
    if (moduleRef) {
      await moduleRef.close();
    }
  });
});
