import { INestApplication } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';
import { ShipmentRepository } from '../../../data/repository/shipmentRepository';
import { AddShipmentsPresenterInterface } from '../../../interface/presenter/addShipmentsPresenterInterface';
import { AddShipmentsUseCase } from '../addShipmentsUseCase';
import { Input } from '../types';

jest.mock('@app/requestContext/requestContext', () => {
  return {
    RequestContext: class DummyRequestContext {
      public static get() {
        return {
          user: {
            organizationId: 'organizationId',
            userId: 'userId',
            role: 'manager',
          },
        };
      }
      public static start(_, next) {
        next();
      }
    },
  };
});

describe('AddShipmentsUseCase', () => {
  let addShipmentsUseCase: AddShipmentsUseCase;
  let moduleRef: TestingModule;
  let app: INestApplication;
  let mockRepository: { save: jest.Mock };
  let mockPresenter: { output: jest.Mock };

  describe('execute', () => {
    it('shipments配列が複数の要素を含む場合に正しく保存できる', async () => {
      await createTestingModule();

      const input: Input = {
        shipments: [
          {
            slipId: 'slip1',
            consignor: { id: 'consignor1', name: '送り主1' },
            consignee: { id: 'consignee1', name: '受取人1' },
            originSpotId: 'spot1',
            destinationSpotId: 'spot2',
            meta: { key1: 'value1' },
          },
          {
            slipId: 'slip2',
            consignor: { id: 'consignor2', name: '送り主2' },
            consignee: { id: 'consignee2', name: '受取人2' },
            originSpotId: 'spot3',
            destinationSpotId: 'spot4',
            meta: { key2: 'value2' },
          },
        ],
      };

      await addShipmentsUseCase.execute(input, 'organizationId');

      expect(mockRepository.save).toHaveBeenCalledWith(
        'organizationId',
        [
          {
            slipId: 'slip1',
            consignor: { id: 'consignor1', name: '送り主1' },
            consignee: { id: 'consignee1', name: '受取人1' },
            originSpotId: 'spot1',
            destinationSpotId: 'spot2',
            meta: { key1: 'value1' },
          },
          {
            slipId: 'slip2',
            consignor: { id: 'consignor2', name: '送り主2' },
            consignee: { id: 'consignee2', name: '受取人2' },
            originSpotId: 'spot3',
            destinationSpotId: 'spot4',
            meta: { key2: 'value2' },
          },
        ],
      );
      expect(mockPresenter.output).toHaveBeenCalledWith(['id1', 'id2']);
    });

    it('shipments配列が1つの要素を含む場合に正しく保存できる', async () => {
      await createTestingModule();

      const input: Input = {
        shipments: [
          {
            slipId: 'slip1',
            consignor: { id: 'consignor1', name: '送り主1' },
            consignee: { id: 'consignee1', name: '受取人1' },
            originSpotId: 'spot1',
            destinationSpotId: 'spot2',
            meta: { key1: 'value1' },
          },
        ],
      };

      await addShipmentsUseCase.execute(input, 'organizationId');

      expect(mockRepository.save).toHaveBeenCalledWith(
        'organizationId',
        [
          {
            slipId: 'slip1',
            consignor: { id: 'consignor1', name: '送り主1' },
            consignee: { id: 'consignee1', name: '受取人1' },
            originSpotId: 'spot1',
            destinationSpotId: 'spot2',
            meta: { key1: 'value1' },
          },
        ],
      );
      expect(mockPresenter.output).toHaveBeenCalledWith(['id1']);
    });

    it('metaがundefinedの場合に正しく保存できる', async () => {
      await createTestingModule();

      const input: Input = {
        shipments: [
          {
            slipId: 'slip1',
            consignor: { id: 'consignor1', name: '送り主1' },
            consignee: { id: 'consignee1', name: '受取人1' },
            originSpotId: 'spot1',
            destinationSpotId: 'spot2',
          },
        ],
      };

      await addShipmentsUseCase.execute(input, 'organizationId');

      expect(mockRepository.save).toHaveBeenCalledWith(
        'organizationId',
        [
          {
            slipId: 'slip1',
            consignor: { id: 'consignor1', name: '送り主1' },
            consignee: { id: 'consignee1', name: '受取人1' },
            originSpotId: 'spot1',
            destinationSpotId: 'spot2',
            meta: undefined,
          },
        ],
      );
      expect(mockPresenter.output).toHaveBeenCalledWith(['id1']);
    });
  });

  const createTestingModule = async () => {
    mockRepository = {
      save: jest.fn().mockImplementation((_, shipments) => {
        return Promise.resolve(shipments.map((_, index) => `id${index + 1}`));
      }),
    };

    mockPresenter = {
      output: jest.fn(),
    };

    moduleRef = await Test.createTestingModule({
      imports: [],
      providers: [
        AddShipmentsUseCase,
        {
          provide: ShipmentRepository,
          useValue: mockRepository,
        },
        {
          provide: 'AddShipmentsPresenter',
          useValue: mockPresenter,
        },
      ],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    addShipmentsUseCase = moduleRef.get<AddShipmentsUseCase>(
      AddShipmentsUseCase,
    );
  };

  afterEach(async () => {
    if (app) {
      await app.close();
    }
    if (moduleRef) {
      await moduleRef.close();
    }
  });
});
