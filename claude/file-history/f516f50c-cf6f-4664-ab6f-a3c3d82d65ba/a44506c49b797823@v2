import { Logger } from '@app/logger';
import { Shipment, ShipmentInsert } from '@app/rdb/db/model';
import { Inject, Injectable } from '@nestjs/common';
import { Knex } from 'knex';
import { ShipmentSaveException } from '../../../../apps/shipment/src/exception/shipmentSaveException';
import { ProviderIdentity } from '../providerIdentity';
import { SaveShipmentEvent } from './types/saveShipmentEvent';
import { SaveShipmentStatus } from './types/saveShipmentStatus';

@Injectable()
export class ShipmentDAO {
  constructor(@Inject(ProviderIdentity) private rdb: Knex) { }

  public async save(shipments: ShipmentInsert[]): Promise<void> {
    if (shipments.length === 0) {
      return;
    }

    await this.rdb('shipment')
      .insert(shipments)
      .onConflict()
      .ignore();
  }

  public get(queries: {
    organizationId: string;
    sinceId?: string;
    count: number;
  }): Promise<Shipment[]> {
    const sql = this.rdb
      .from('shipment')
      .select(
        'id',
        'organization_id as organizationId',
        'slip_id as slipId',
        'consignor',
        'consignee',
        'origin_spot_id as originSpotId',
        'destination_spot_id as destinationSpotId',
        'meta',
      )
      .where('organization_id', '=', queries.organizationId);

    if (queries.sinceId) {
      sql.where('id', '>=', queries.sinceId);
    }

    return sql.orderBy('id', 'asc').limit(queries.count);
  }

  public async saveEvents(
    events: SaveShipmentEvent[],
    statuses: SaveShipmentStatus[]
  ): Promise<void> {
    if (events.length === 0) {
      return;
    }

    // デバッグ: 受信データをログ出力
    Logger.info('[DEBUG] saveEvents - 受信データ', {
      eventsCount: events.length,
      statusesCount: statuses.length,
      events: JSON.stringify(events),
      statuses: JSON.stringify(statuses),
    });

    const eventRecords = events.map((e) => ({
      id: e.id,
      shipment_id: e.shipmentId,
      type: e.type,
      original_spot_id: e.originalSpotId,
      geocode: e.geocode ? this.rdb.raw(`point(${e.geocode.x},${e.geocode.y})`) : null,
      update_by: e.updateBy,
      executed_at: e.executedAt,
    }));

    const statusRecords = statuses.map((s) => ({
      shipment_id: s.shipmentId,
      status: s.status,
      executed_at: s.executedAt,
    }));

    // デバッグ: 生成されたレコードをログ出力
    Logger.info('[DEBUG] saveEvents - 生成されたレコード', {
      eventRecords: JSON.stringify(eventRecords, (key, value) => {
        if (value && typeof value === 'object' && value.constructor && value.constructor.name === 'Raw') {
          return `[Raw SQL: ${value.toString()}]`;
        }
        return value;
      }),
      statusRecords: JSON.stringify(statusRecords),
    });

    return this.rdb
      .transaction(async (trx) => {
        Logger.info('[DEBUG] saveEvents - トランザクション開始');

        await trx('shipment_event').insert(eventRecords);
        Logger.info('[DEBUG] saveEvents - shipment_eventへのINSERT成功');

        if (statusRecords.length > 0) {
          await Promise.all(
            statusRecords.map((record) =>
              trx('shipment_status')
                .insert(record)
                .onConflict('shipment_id')
                .merge(['status', 'executed_at'])
            )
          );
          Logger.info('[DEBUG] saveEvents - shipment_statusへのINSERT/UPDATE成功');
        }
      })
      .catch((error: Error) => {
        // デバッグ: エラー詳細をログ出力
        Logger.error('[DEBUG] saveEvents - エラー発生', {
          errorMessage: error.message,
          errorStack: error.stack,
          errorName: error.name,
          // Knexエラーの場合は追加情報を出力
          ...(error as any).code && { errorCode: (error as any).code },
          ...(error as any).detail && { errorDetail: (error as any).detail },
          ...(error as any).constraint && { errorConstraint: (error as any).constraint },
        });
        throw new ShipmentSaveException('シップメントイベント情報の保存に失敗しました。');
      });
  }
}
