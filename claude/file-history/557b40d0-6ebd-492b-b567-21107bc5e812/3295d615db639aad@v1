# 拠点間ビデオ通話Webアプリケーション 設計書

## 1. システム概要

### 1.1 システム構成図

```
┌─────────────────────────────────────────────────────────────────┐
│                        クライアント                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              React SPA (front/)                          │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │   │
│  │  │ Presentation│  │ Application │  │    Domain       │  │   │
│  │  │    Layer    │──│    Layer    │──│    Layer        │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ HTTPS/WebSocket
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        サーバー                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Node.js/Express (server/)                   │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │   │
│  │  │ Presentation│  │ Application │  │ Infrastructure  │  │   │
│  │  │  (Routes)   │──│  (UseCases) │──│ (Repository)    │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────┐    ┌──────────────────┐
│    Supabase      │    │   Zoom Video     │
│   (PostgreSQL)   │    │      SDK         │
└──────────────────┘    └──────────────────┘
```

### 1.2 技術スタック

| カテゴリ | 技術 | バージョン |
|---------|------|-----------|
| フロントエンド | React | 18.x (最新安定版) |
| フロントエンド | TypeScript | 5.x (最新安定版) |
| フロントエンド | Vite | 5.x (最新安定版) |
| フロントエンド | React Router | 6.x (最新安定版) |
| バックエンド | Node.js | 20.x LTS |
| バックエンド | Express | 4.x (最新安定版) |
| バックエンド | TypeScript | 5.x (最新安定版) |
| ORM | Prisma | 5.x (最新安定版) |
| データベース | Supabase (PostgreSQL) | - |
| ビデオ通話 | Zoom Video SDK | 2.3.5 |
| テスト | Vitest | 1.x (最新安定版) |
| テスト | Testing Library | 14.x (最新安定版) |

### 1.3 環境変数設計

#### 1.3.1 バックエンド環境変数

```bash
# server/.env

# Database
DATABASE_URL="postgresql://user:password@host:5432/dbname"

# JWT (アプリケーション認証用)
JWT_SECRET="your-jwt-secret-key"
JWT_EXPIRES_IN="24h"

# Zoom Video SDK (運営側で1アカウント管理)
ZOOM_SDK_KEY="your-zoom-sdk-key"
ZOOM_SDK_SECRET="your-zoom-sdk-secret"
ZOOM_JWT_EXPIRES_IN="7200"  # 秒（2時間）

# Server
PORT="3001"
NODE_ENV="development"
CORS_ORIGIN="http://localhost:5173"

# Operating Hours
WARNING_THRESHOLD_MINUTES="5"
```

#### 1.3.2 フロントエンド環境変数

```bash
# front/.env

VITE_API_BASE_URL="http://localhost:3001/api"
VITE_ZOOM_WEB_ENDPOINT="zoom.us"
```

#### 1.3.3 環境変数の管理方針

| 項目 | 方針 |
|------|------|
| 本番環境 | 環境変数は外部シークレット管理サービスで管理 |
| 開発環境 | `.env.local` を使用（Git管理対象外） |
| サンプル | `.env.example` をリポジトリに含める |
| SDK認証情報 | `ZOOM_SDK_KEY` / `ZOOM_SDK_SECRET` はバックエンドのみで使用 |
| フロントエンド | SDK Secretは絶対に公開しない（JWTのみ使用） |

#### 1.3.4 Zoom SDK認証フロー

```
┌─────────────────────────────────────────────────────────────────┐
│  環境変数                                                        │
│  ZOOM_SDK_KEY, ZOOM_SDK_SECRET                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  サーバー (ZoomJwtService.ts)                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 1. SDK Key/Secret を環境変数から読み込み                    │   │
│  │ 2. セッション参加時にZoom SDK JWT生成                       │   │
│  │    - topic: {companyId}-video-session (会社分離)           │   │
│  │    - role: 1 (host) または 0 (participant)                 │   │
│  │    - 有効期限: 2時間                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ JWT トークン
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  クライアント (ZoomClient.ts)                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 1. サーバーからZoom SDK JWTを受け取る                       │   │
│  │ 2. ZoomClient.init() で初期化                              │   │
│  │ 3. ZoomClient.join(topic, jwt, userName) で接続            │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

> **Note**: Zoom SDK Key/Secretは運営側で1つのアカウントとして管理し、会社ごとに異なるtopicを使用することでマルチテナント分離を実現します。

### 1.4 デザインパターン

本アプリケーションでは以下のデザインパターンを採用し、保守性・拡張性・テスタビリティを向上させます。

#### 1.4.1 Observer Pattern（参加者状態・稼働時間監視）

参加者の入退室や稼働時間の変化を、関心のあるコンポーネントに通知します。

```
┌─────────────────────────────────────────────────────────────────┐
│                      Subject (Observable)                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              VideoSessionSubject                         │   │
│  │  - observers: Set<VideoSessionObserver>                  │   │
│  │  - participants: Participant[]                           │   │
│  │  + subscribe(observer): void                             │   │
│  │  + unsubscribe(observer): void                           │   │
│  │  + notify(event): void                                   │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ notify
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Observers (Subscribers)                       │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────────┐   │
│  │ VideoGrid     │  │ VolumeManager │  │ ParticipantCount  │   │
│  │ Observer      │  │ Observer      │  │ Observer          │   │
│  └───────────────┘  └───────────────┘  └───────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

**実装:**

```typescript
// features/video-call/observers/VideoSessionObserver.ts

interface VideoSessionEvent {
  type: 'PARTICIPANT_JOIN' | 'PARTICIPANT_LEAVE' | 'PARTICIPANT_UPDATE';
  participant: Participant;
  timestamp: Date;
}

interface VideoSessionObserver {
  onSessionEvent(event: VideoSessionEvent): void;
}

// features/video-call/observers/VideoSessionSubject.ts

class VideoSessionSubject {
  private observers: Set<VideoSessionObserver> = new Set();

  subscribe(observer: VideoSessionObserver): () => void {
    this.observers.add(observer);
    return () => this.unsubscribe(observer);
  }

  unsubscribe(observer: VideoSessionObserver): void {
    this.observers.delete(observer);
  }

  notify(event: VideoSessionEvent): void {
    this.observers.forEach(observer => observer.onSessionEvent(event));
  }
}
```

**稼働時間監視への適用:**

```typescript
// features/operating-hours/observers/OperatingHoursObserver.ts

interface OperatingHoursEvent {
  type: 'WARNING' | 'EXPIRED' | 'STATUS_CHANGE';
  remainingMinutes: number;
  message: string;
}

interface OperatingHoursObserver {
  onOperatingHoursEvent(event: OperatingHoursEvent): void;
}

// 使用例: 複数コンポーネントが稼働時間の変化を購読
class WarningNotificationObserver implements OperatingHoursObserver {
  onOperatingHoursEvent(event: OperatingHoursEvent): void {
    if (event.type === 'WARNING') {
      showNotification(event.message);
    }
  }
}

class AutoDisconnectObserver implements OperatingHoursObserver {
  constructor(private disconnectFn: () => Promise<void>) {}

  onOperatingHoursEvent(event: OperatingHoursEvent): void {
    if (event.type === 'EXPIRED') {
      this.disconnectFn();
    }
  }
}
```

---

#### 1.4.2 Facade Pattern（Zoom SDK操作の簡略化）

複雑なZoom SDKのAPIを、アプリケーション固有のシンプルなインターフェースで隠蔽します。

```
┌─────────────────────────────────────────────────────────────────┐
│                        Client Code                               │
│                   (VideoCallPage, UseCases)                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 簡潔なAPI呼び出し
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     ZoomVideoFacade                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  + joinSession(config: SessionConfig): Promise<void>     │   │
│  │  + leaveSession(): Promise<void>                         │   │
│  │  + toggleMicrophone(): Promise<boolean>                  │   │
│  │  + toggleCamera(): Promise<boolean>                      │   │
│  │  + setParticipantVolume(id, level): Promise<void>        │   │
│  │  + switchMainDisplay(siteId): void                       │   │
│  │  + getParticipants(): Participant[]                      │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 内部で複雑な操作を実行
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Zoom SDK Subsystems                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │ ZoomVideo    │  │ MediaStream  │  │ Participant          │  │
│  │ Client       │  │              │  │ Manager              │  │
│  ├──────────────┤  ├──────────────┤  ├──────────────────────┤  │
│  │ init()       │  │ startAudio() │  │ getAllUser()         │  │
│  │ join()       │  │ startVideo() │  │ getUser()            │  │
│  │ leave()      │  │ stopAudio()  │  │ adjustUserVolume()   │  │
│  │ on()         │  │ stopVideo()  │  │ renderVideo()        │  │
│  │ off()        │  │ muteAudio()  │  │ stopRenderVideo()    │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

**実装:**

```typescript
// features/video-call/facade/ZoomVideoFacade.ts

interface SessionConfig {
  topic: string;
  token: string;
  userName: string;
  videoQuality?: VideoQuality;
}

class ZoomVideoFacade {
  private client: typeof ZoomVideo;
  private mediaStream: MediaStream | null = null;
  private sessionSubject: VideoSessionSubject;

  constructor(sessionSubject: VideoSessionSubject) {
    this.client = ZoomVideo.createClient();
    this.sessionSubject = sessionSubject;
  }

  async joinSession(config: SessionConfig): Promise<void> {
    await this.client.init('en-US', 'Global', { patchJsMedia: true });
    await this.client.join(config.topic, config.token, config.userName);
    this.mediaStream = this.client.getMediaStream();
    this.setupEventListeners();
  }

  async leaveSession(): Promise<void> {
    await this.client.leave();
    this.mediaStream = null;
  }

  async toggleMicrophone(): Promise<boolean> {
    if (!this.mediaStream) throw new Error('Not connected');

    const isCurrentlyMuted = this.mediaStream.isAudioMuted();
    if (isCurrentlyMuted) {
      await this.mediaStream.unmuteAudio();
    } else {
      await this.mediaStream.muteAudio();
    }
    return !isCurrentlyMuted;
  }

  async toggleCamera(): Promise<boolean> {
    if (!this.mediaStream) throw new Error('Not connected');

    const isCapturing = this.mediaStream.isCapturingVideo();
    if (isCapturing) {
      await this.mediaStream.stopVideo();
    } else {
      await this.mediaStream.startVideo({ videoQuality: VideoQuality.Video_1080P });
    }
    return !isCapturing;
  }

  async setParticipantVolume(participantId: string, volume: number): Promise<void> {
    if (!this.mediaStream) throw new Error('Not connected');
    await this.mediaStream.adjustUserAudioVolumeLocally(participantId, volume);
  }

  private setupEventListeners(): void {
    this.client.on('user-added', (participants) => {
      participants.forEach(p => {
        this.sessionSubject.notify({
          type: 'PARTICIPANT_JOIN',
          participant: this.mapToParticipant(p),
          timestamp: new Date()
        });
      });
    });

    this.client.on('user-removed', (participants) => {
      participants.forEach(p => {
        this.sessionSubject.notify({
          type: 'PARTICIPANT_LEAVE',
          participant: this.mapToParticipant(p),
          timestamp: new Date()
        });
      });
    });
  }

  private mapToParticipant(sdkUser: ZoomParticipant): Participant {
    return {
      id: String(sdkUser.oderId),
      name: sdkUser.displayName,
      isVideoOn: sdkUser.bVideoOn,
      isAudioOn: !sdkUser.muted
    };
  }
}
```

---

#### 1.4.3 Adapter Pattern（SDK依存の分離）

Zoom SDKへの依存をアプリケーション層から分離し、テスタビリティと将来のSDK変更への耐性を確保します。

```
┌─────────────────────────────────────────────────────────────────┐
│                     Application Layer                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   JoinSessionUseCase                     │   │
│  │  - videoService: IVideoService  ← インターフェースに依存   │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 依存性の逆転
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Domain Layer (Interface)                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    IVideoService                         │   │
│  │  + connect(config): Promise<void>                        │   │
│  │  + disconnect(): Promise<void>                           │   │
│  │  + toggleAudio(): Promise<boolean>                       │   │
│  │  + toggleVideo(): Promise<boolean>                       │   │
│  │  + setVolume(participantId, level): Promise<void>        │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              ▲
                              │ 実装
          ┌───────────────────┴───────────────────┐
          │                                       │
┌─────────────────────┐               ┌─────────────────────┐
│ ZoomVideoAdapter    │               │ MockVideoAdapter    │
│ (本番用)             │               │ (テスト用)           │
├─────────────────────┤               ├─────────────────────┤
│ - facade: Zoom      │               │ - state: MockState  │
│   VideoFacade       │               │                     │
│                     │               │                     │
│ + connect()         │               │ + connect()         │
│ + disconnect()      │               │ + disconnect()      │
│ + toggleAudio()     │               │ + toggleAudio()     │
└─────────────────────┘               └─────────────────────┘
```

**実装:**

```typescript
// features/video-call/services/IVideoService.ts

interface VideoConnectionConfig {
  sessionTopic: string;
  token: string;
  userName: string;
}

interface IVideoService {
  connect(config: VideoConnectionConfig): Promise<void>;
  disconnect(): Promise<void>;
  toggleAudio(): Promise<boolean>;
  toggleVideo(): Promise<boolean>;
  setVolume(participantId: string, level: VolumeLevel): Promise<void>;
  getParticipants(): Participant[];
  subscribeToEvents(observer: VideoSessionObserver): () => void;
}

// features/video-call/services/ZoomVideoAdapter.ts

class ZoomVideoAdapter implements IVideoService {
  private facade: ZoomVideoFacade;

  constructor(sessionSubject: VideoSessionSubject) {
    this.facade = new ZoomVideoFacade(sessionSubject);
  }

  async connect(config: VideoConnectionConfig): Promise<void> {
    await this.facade.joinSession({
      topic: config.sessionTopic,
      token: config.token,
      userName: config.userName,
      videoQuality: VideoQuality.Video_1080P
    });
  }

  async disconnect(): Promise<void> {
    await this.facade.leaveSession();
  }

  async toggleAudio(): Promise<boolean> {
    return this.facade.toggleMicrophone();
  }

  async toggleVideo(): Promise<boolean> {
    return this.facade.toggleCamera();
  }

  async setVolume(participantId: string, level: VolumeLevel): Promise<void> {
    await this.facade.setParticipantVolume(participantId, level.value);
  }

  getParticipants(): Participant[] {
    return this.facade.getParticipants();
  }

  subscribeToEvents(observer: VideoSessionObserver): () => void {
    return this.facade.subscribe(observer);
  }
}

// features/video-call/services/MockVideoAdapter.ts (テスト用)

class MockVideoAdapter implements IVideoService {
  private connected = false;
  private audioOn = false;
  private videoOn = false;
  private participants: Participant[] = [];

  async connect(_config: VideoConnectionConfig): Promise<void> {
    this.connected = true;
  }

  async disconnect(): Promise<void> {
    this.connected = false;
  }

  async toggleAudio(): Promise<boolean> {
    this.audioOn = !this.audioOn;
    return this.audioOn;
  }

  async toggleVideo(): Promise<boolean> {
    this.videoOn = !this.videoOn;
    return this.videoOn;
  }

  async setVolume(_participantId: string, _level: VolumeLevel): Promise<void> {
    // Mock implementation
  }

  getParticipants(): Participant[] {
    return this.participants;
  }

  // テスト用ヘルパー
  simulateParticipantJoin(participant: Participant): void {
    this.participants.push(participant);
  }

  subscribeToEvents(_observer: VideoSessionObserver): () => void {
    return () => {};
  }
}
```

---

#### 1.4.4 State Pattern（セッション状態管理）

セッションの状態遷移を明確に定義し、各状態での振る舞いをカプセル化します。

```
┌─────────────────────────────────────────────────────────────────┐
│                      State Diagram                               │
│                                                                  │
│     ┌─────────┐    connect()    ┌────────────┐                  │
│     │  Idle   │ ──────────────▶ │ Connecting │                  │
│     └─────────┘                 └────────────┘                  │
│          ▲                            │                          │
│          │                            │ success                  │
│          │ disconnect()               ▼                          │
│     ┌────┴──────┐              ┌────────────┐                   │
│     │Disconnected│◀──────────── │ Connected  │                   │
│     └───────────┘  disconnect() └────────────┘                  │
│          ▲                            │                          │
│          │              error         │ error                    │
│          └────────────────────────────┘                          │
└─────────────────────────────────────────────────────────────────┘
```

**実装:**

```typescript
// features/video-call/states/SessionState.ts

interface SessionContext {
  videoService: IVideoService;
  config: VideoConnectionConfig;
  onStateChange: (state: SessionState) => void;
  onError: (error: Error) => void;
}

abstract class SessionState {
  constructor(protected context: SessionContext) {}

  abstract get status(): SessionStatus;

  // 各状態で許可される操作（デフォルトは何もしない）
  async connect(): Promise<void> {
    console.warn(`Cannot connect in ${this.status} state`);
  }

  async disconnect(): Promise<void> {
    console.warn(`Cannot disconnect in ${this.status} state`);
  }

  async toggleAudio(): Promise<boolean> {
    console.warn(`Cannot toggle audio in ${this.status} state`);
    return false;
  }

  async toggleVideo(): Promise<boolean> {
    console.warn(`Cannot toggle video in ${this.status} state`);
    return false;
  }

  protected transitionTo(state: SessionState): void {
    this.context.onStateChange(state);
  }
}

// 各状態の実装

class IdleState extends SessionState {
  get status(): SessionStatus {
    return 'idle';
  }

  async connect(): Promise<void> {
    this.transitionTo(new ConnectingState(this.context));
  }
}

class ConnectingState extends SessionState {
  get status(): SessionStatus {
    return 'connecting';
  }

  constructor(context: SessionContext) {
    super(context);
    this.performConnection();
  }

  private async performConnection(): Promise<void> {
    try {
      await this.context.videoService.connect(this.context.config);
      this.transitionTo(new ConnectedState(this.context));
    } catch (error) {
      this.context.onError(error as Error);
      this.transitionTo(new DisconnectedState(this.context));
    }
  }
}

class ConnectedState extends SessionState {
  get status(): SessionStatus {
    return 'connected';
  }

  async disconnect(): Promise<void> {
    try {
      await this.context.videoService.disconnect();
      this.transitionTo(new DisconnectedState(this.context));
    } catch (error) {
      this.context.onError(error as Error);
      this.transitionTo(new DisconnectedState(this.context));
    }
  }

  async toggleAudio(): Promise<boolean> {
    return this.context.videoService.toggleAudio();
  }

  async toggleVideo(): Promise<boolean> {
    return this.context.videoService.toggleVideo();
  }
}

class DisconnectedState extends SessionState {
  get status(): SessionStatus {
    return 'disconnected';
  }

  async connect(): Promise<void> {
    this.transitionTo(new ConnectingState(this.context));
  }
}

// 状態マシンのコントローラー

class SessionStateMachine {
  private currentState: SessionState;

  constructor(
    private videoService: IVideoService,
    private config: VideoConnectionConfig
  ) {
    const context: SessionContext = {
      videoService,
      config,
      onStateChange: (state) => { this.currentState = state; },
      onError: (error) => { console.error('Session error:', error); }
    };
    this.currentState = new IdleState(context);
  }

  get status(): SessionStatus {
    return this.currentState.status;
  }

  connect(): Promise<void> {
    return this.currentState.connect();
  }

  disconnect(): Promise<void> {
    return this.currentState.disconnect();
  }

  toggleAudio(): Promise<boolean> {
    return this.currentState.toggleAudio();
  }

  toggleVideo(): Promise<boolean> {
    return this.currentState.toggleVideo();
  }
}
```

**React Hooksとの統合:**

```typescript
// features/video-call/hooks/useSessionState.ts

export const useSessionState = (videoService: IVideoService, config: VideoConnectionConfig) => {
  const [status, setStatus] = useState<SessionStatus>('idle');
  const [error, setError] = useState<Error | null>(null);

  const stateMachineRef = useRef<SessionStateMachine>();

  useEffect(() => {
    const context: SessionContext = {
      videoService,
      config,
      onStateChange: (state) => setStatus(state.status),
      onError: setError
    };
    stateMachineRef.current = new SessionStateMachine(videoService, config);
  }, [videoService, config]);

  const connect = useCallback(() => {
    return stateMachineRef.current?.connect();
  }, []);

  const disconnect = useCallback(() => {
    return stateMachineRef.current?.disconnect();
  }, []);

  const toggleAudio = useCallback(() => {
    return stateMachineRef.current?.toggleAudio();
  }, []);

  const toggleVideo = useCallback(() => {
    return stateMachineRef.current?.toggleVideo();
  }, []);

  return {
    status,
    error,
    connect,
    disconnect,
    toggleAudio,
    toggleVideo,
    isConnected: status === 'connected',
    isConnecting: status === 'connecting'
  };
};
```

---

#### 1.4.5 パターン適用の全体像

```
┌─────────────────────────────────────────────────────────────────┐
│                     Presentation Layer                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ VideoCallPage                                            │   │
│  │   └── useSessionState (State Pattern)                    │   │
│  │         └── SessionStateMachine                          │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Application Layer                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ VideoSessionSubject (Observer Pattern)                   │   │
│  │   └── observers: [VideoGrid, VolumeManager, ...]         │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Domain Layer                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ IVideoService (Adapter Pattern - Interface)              │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Infrastructure Layer                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ ZoomVideoAdapter (Adapter Pattern - Implementation)      │   │
│  │   └── ZoomVideoFacade (Facade Pattern)                   │   │
│  │         └── ZoomVideo SDK                                │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

| パターン | 責務 | 主なファイル |
|---------|------|-------------|
| Observer | イベント通知の疎結合化 | `features/video-call/observers/` |
| Facade | SDK複雑性の隠蔽 | `features/video-call/facade/ZoomVideoFacade.ts` |
| Adapter | SDK依存の分離 | `features/video-call/services/IVideoService.ts`, `ZoomVideoAdapter.ts` |
| State | 状態遷移の明確化 | `features/video-call/states/` |

---

## 2. ディレクトリ構成

### 2.1 フロントエンド (front/) - Feature-Based Architecture

機能（Feature）ごとにコードを分割し、各機能が独立して開発・テスト可能な構造を採用します。

```
front/
├── src/
│   ├── app/                           # アプリケーション設定
│   │   ├── App.tsx                    # ルートコンポーネント
│   │   ├── routes.tsx                 # ルーティング設定
│   │   └── providers/                 # グローバルProvider
│   │       ├── index.tsx
│   │       └── AppProviders.tsx
│   │
│   ├── features/                      # ★ 機能モジュール（メイン）
│   │   │
│   │   ├── auth/                      # 認証機能
│   │   │   ├── components/
│   │   │   │   ├── LoginForm/
│   │   │   │   │   ├── LoginForm.tsx
│   │   │   │   │   ├── LoginForm.test.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   └── index.ts
│   │   │   ├── hooks/
│   │   │   │   ├── useAuth.ts
│   │   │   │   └── index.ts
│   │   │   ├── api/
│   │   │   │   └── authApi.ts
│   │   │   ├── context/
│   │   │   │   └── AuthContext.tsx
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts               # Public API
│   │   │
│   │   ├── video-call/                # ビデオ通話機能
│   │   │   ├── components/
│   │   │   │   ├── MainVideoDisplay/
│   │   │   │   │   ├── MainVideoDisplay.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   ├── SubVideoDisplay/
│   │   │   │   │   ├── SubVideoDisplay.tsx
│   │   │   │   │   ├── VideoGrid.tsx
│   │   │   │   │   ├── VideoThumbnail.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   ├── SelfVideoDisplay/
│   │   │   │   │   ├── SelfVideoDisplay.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   ├── VideoControls/
│   │   │   │   │   ├── VideoControls.tsx
│   │   │   │   │   ├── MicrophoneButton.tsx
│   │   │   │   │   ├── CameraButton.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   ├── VerticalLayout/
│   │   │   │   │   ├── VerticalLayout.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   └── index.ts
│   │   │   ├── hooks/
│   │   │   │   ├── useSessionState.ts      # State Pattern統合
│   │   │   │   ├── useKeyboardShortcut.ts
│   │   │   │   ├── useVolumeControl.ts
│   │   │   │   └── index.ts
│   │   │   ├── services/                   # Adapter Pattern
│   │   │   │   ├── IVideoService.ts        # インターフェース
│   │   │   │   ├── ZoomVideoAdapter.ts     # 本番実装
│   │   │   │   ├── MockVideoAdapter.ts     # テスト用
│   │   │   │   └── index.ts
│   │   │   ├── facade/                     # Facade Pattern
│   │   │   │   ├── ZoomVideoFacade.ts
│   │   │   │   └── index.ts
│   │   │   ├── states/                     # State Pattern
│   │   │   │   ├── SessionState.ts
│   │   │   │   ├── IdleState.ts
│   │   │   │   ├── ConnectingState.ts
│   │   │   │   ├── ConnectedState.ts
│   │   │   │   ├── DisconnectedState.ts
│   │   │   │   └── index.ts
│   │   │   ├── observers/                  # Observer Pattern
│   │   │   │   ├── VideoSessionObserver.ts
│   │   │   │   ├── VideoSessionSubject.ts
│   │   │   │   └── index.ts
│   │   │   ├── context/
│   │   │   │   └── VideoContext.tsx
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts                    # Public API
│   │   │
│   │   ├── operating-hours/           # 稼働時間管理機能
│   │   │   ├── components/
│   │   │   │   ├── OperatingHoursWarning/
│   │   │   │   │   ├── OperatingHoursWarning.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   └── index.ts
│   │   │   ├── hooks/
│   │   │   │   ├── useOperatingHoursMonitor.ts
│   │   │   │   └── index.ts
│   │   │   ├── api/
│   │   │   │   └── scheduleApi.ts
│   │   │   ├── observers/
│   │   │   │   ├── OperatingHoursObserver.ts
│   │   │   │   ├── OperatingHoursSubject.ts
│   │   │   │   └── index.ts
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   │
│   │   └── sites/                     # 拠点管理機能
│   │       ├── api/
│   │       │   └── siteApi.ts
│   │       ├── hooks/
│   │       │   └── useSites.ts
│   │       ├── types/
│   │       │   └── index.ts
│   │       └── index.ts
│   │
│   ├── entities/                      # 共有ドメインエンティティ
│   │   ├── user/
│   │   │   ├── User.ts
│   │   │   └── index.ts
│   │   ├── company/
│   │   │   ├── Company.ts
│   │   │   └── index.ts
│   │   ├── site/
│   │   │   ├── Site.ts
│   │   │   └── index.ts
│   │   ├── participant/
│   │   │   ├── Participant.ts
│   │   │   └── index.ts
│   │   └── index.ts
│   │
│   ├── shared/                        # 共有リソース
│   │   ├── components/                # 汎用UIコンポーネント
│   │   │   ├── Button/
│   │   │   │   ├── Button.tsx
│   │   │   │   └── index.ts
│   │   │   ├── Icon/
│   │   │   │   ├── Icon.tsx
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   ├── hooks/                     # 汎用フック
│   │   │   ├── useFullScreen.ts
│   │   │   └── index.ts
│   │   ├── lib/                       # ユーティリティ
│   │   │   ├── apiClient.ts
│   │   │   └── index.ts
│   │   ├── constants/
│   │   │   └── index.ts
│   │   └── types/
│   │       └── index.ts
│   │
│   ├── pages/                         # ページコンポーネント
│   │   ├── LoginPage/
│   │   │   ├── LoginPage.tsx
│   │   │   └── index.ts
│   │   ├── VideoCallPage/
│   │   │   ├── VideoCallPage.tsx
│   │   │   └── index.ts
│   │   ├── SessionEndedPage/
│   │   │   ├── SessionEndedPage.tsx
│   │   │   └── index.ts
│   │   └── index.ts
│   │
│   └── main.tsx                       # エントリポイント
│
├── tests/
│   ├── setup.ts
│   ├── mocks/
│   │   └── handlers.ts
│   └── e2e/
│       └── video-call.spec.ts
│
├── public/
├── index.html
├── vite.config.ts
├── tsconfig.json
└── package.json
```

#### Feature モジュールのルール

```typescript
// features/video-call/index.ts（Public API）
// 外部に公開するものだけをexport

// Components
export { MainVideoDisplay } from './components/MainVideoDisplay';
export { SubVideoDisplay } from './components/SubVideoDisplay';
export { SelfVideoDisplay } from './components/SelfVideoDisplay';
export { VideoControls } from './components/VideoControls';
export { VerticalLayout } from './components/VerticalLayout';

// Hooks
export { useSessionState } from './hooks';
export { useKeyboardShortcut } from './hooks';

// Context
export { VideoContext, VideoProvider } from './context/VideoContext';

// Types
export type { Participant, SessionStatus } from './types';

// 内部実装（ZoomVideoFacade, States等）はexportしない
```

#### 依存関係のルール

```
┌─────────────────────────────────────────────────────────────┐
│  pages/         →  features を組み合わせてページを構成      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  features/      →  他のfeatureを直接参照しない              │
│                    （共有が必要なら shared/ か entities/）  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  shared/        →  features に依存しない                    │
│  entities/      →  どこからでも参照可能                     │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 バックエンド (server/) - Feature-Based Architecture

バックエンドも機能ごとにモジュール化し、Vertical Slice Architectureを採用します。

```
server/
├── src/
│   ├── app/                           # アプリケーション設定
│   │   ├── app.ts                     # Expressアプリ設定
│   │   ├── server.ts                  # サーバー起動
│   │   └── routes.ts                  # ルート集約
│   │
│   ├── features/                      # ★ 機能モジュール（メイン）
│   │   │
│   │   ├── auth/                      # 認証機能
│   │   │   ├── controller/
│   │   │   │   └── AuthController.ts
│   │   │   ├── routes/
│   │   │   │   └── authRoutes.ts
│   │   │   ├── usecases/
│   │   │   │   ├── LoginUseCase.ts
│   │   │   │   └── GenerateJwtUseCase.ts
│   │   │   ├── validators/
│   │   │   │   └── authValidator.ts
│   │   │   ├── dto/
│   │   │   │   └── AuthDto.ts
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts               # Public API
│   │   │
│   │   ├── session/                   # セッション管理機能
│   │   │   ├── controller/
│   │   │   │   └── SessionController.ts
│   │   │   ├── routes/
│   │   │   │   └── sessionRoutes.ts
│   │   │   ├── usecases/
│   │   │   │   ├── CreateSessionUseCase.ts
│   │   │   │   └── JoinSessionUseCase.ts
│   │   │   ├── services/
│   │   │   │   └── ZoomJwtService.ts
│   │   │   ├── validators/
│   │   │   │   └── sessionValidator.ts
│   │   │   ├── dto/
│   │   │   │   └── SessionDto.ts
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   │
│   │   ├── operating-hours/           # 稼働時間管理機能
│   │   │   ├── controller/
│   │   │   │   └── ScheduleController.ts
│   │   │   ├── routes/
│   │   │   │   └── scheduleRoutes.ts
│   │   │   ├── usecases/
│   │   │   │   ├── CheckOperatingHoursUseCase.ts
│   │   │   │   ├── GetScheduleUseCase.ts
│   │   │   │   └── UpdateScheduleUseCase.ts
│   │   │   ├── services/
│   │   │   │   └── OperatingHoursService.ts
│   │   │   ├── middleware/
│   │   │   │   └── operatingHoursMiddleware.ts
│   │   │   ├── dto/
│   │   │   │   └── ScheduleDto.ts
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   │
│   │   └── sites/                     # 拠点管理機能
│   │       ├── controller/
│   │       │   └── SiteController.ts
│   │       ├── routes/
│   │       │   └── siteRoutes.ts
│   │       ├── usecases/
│   │       │   └── GetSitesUseCase.ts
│   │       ├── dto/
│   │       │   └── SiteDto.ts
│   │       ├── types/
│   │       │   └── index.ts
│   │       └── index.ts
│   │
│   ├── entities/                      # 共有ドメインエンティティ
│   │   ├── user/
│   │   │   ├── User.ts
│   │   │   ├── UserId.ts
│   │   │   └── index.ts
│   │   ├── company/
│   │   │   ├── Company.ts
│   │   │   ├── CompanyId.ts
│   │   │   └── index.ts
│   │   ├── site/
│   │   │   ├── Site.ts
│   │   │   └── index.ts
│   │   ├── session/
│   │   │   ├── Session.ts
│   │   │   ├── SessionTopic.ts
│   │   │   └── index.ts
│   │   ├── schedule/
│   │   │   ├── OperatingSchedule.ts
│   │   │   ├── OperatingScheduleException.ts
│   │   │   ├── TimeRange.ts
│   │   │   └── index.ts
│   │   └── index.ts
│   │
│   ├── shared/                        # 共有リソース
│   │   ├── middleware/                # 共通ミドルウェア
│   │   │   ├── authMiddleware.ts
│   │   │   ├── errorMiddleware.ts
│   │   │   ├── validationMiddleware.ts
│   │   │   └── index.ts
│   │   ├── errors/                    # 共通エラー
│   │   │   ├── AppError.ts
│   │   │   ├── AuthError.ts
│   │   │   ├── NotFoundError.ts
│   │   │   └── index.ts
│   │   ├── lib/                       # ユーティリティ
│   │   │   ├── jwt.ts
│   │   │   ├── password.ts
│   │   │   └── index.ts
│   │   ├── constants/
│   │   │   └── index.ts
│   │   └── types/
│   │       └── index.ts
│   │
│   ├── infrastructure/                # インフラストラクチャ
│   │   ├── database/
│   │   │   ├── prisma/
│   │   │   │   ├── client.ts
│   │   │   │   └── schema.prisma
│   │   │   └── repositories/          # リポジトリ実装
│   │   │       ├── UserRepository.ts
│   │   │       ├── CompanyRepository.ts
│   │   │       ├── SiteRepository.ts
│   │   │       ├── SessionRepository.ts
│   │   │       ├── ScheduleRepository.ts
│   │   │       └── index.ts
│   │   └── external/                  # 外部サービス
│   │       └── zoom/
│   │           └── ZoomClient.ts
│   │
│   └── config/                        # 設定
│       ├── env.ts
│       ├── constants.ts
│       └── index.ts
│
├── tests/
│   ├── setup.ts
│   ├── features/                      # 機能ごとのテスト
│   │   ├── auth/
│   │   │   └── auth.test.ts
│   │   ├── session/
│   │   │   └── session.test.ts
│   │   └── operating-hours/
│   │       └── operating-hours.test.ts
│   └── integration/
│       └── api.test.ts
│
├── prisma/
│   ├── schema.prisma
│   └── migrations/
│
├── tsconfig.json
└── package.json
```

#### Feature モジュールのルール（バックエンド）

```typescript
// features/session/index.ts（Public API）
// 外部に公開するものだけをexport

// Routes（app.tsで使用）
export { sessionRoutes } from './routes/sessionRoutes';

// UseCases（他のfeatureから使用する場合）
export { JoinSessionUseCase } from './usecases/JoinSessionUseCase';

// Types
export type { SessionDto } from './dto/SessionDto';

// 内部実装（ZoomJwtService等）はexportしない
```

#### ルート集約

```typescript
// app/routes.ts
import { Router } from 'express';
import { authRoutes } from '@/features/auth';
import { sessionRoutes } from '@/features/session';
import { scheduleRoutes } from '@/features/operating-hours';
import { siteRoutes } from '@/features/sites';

const router = Router();

router.use('/auth', authRoutes);
router.use('/sessions', sessionRoutes);
router.use('/schedules', scheduleRoutes);
router.use('/sites', siteRoutes);

export { router };
```

#### 依存関係のルール（バックエンド）

```
┌─────────────────────────────────────────────────────────────┐
│  app/            →  features のルートを集約                  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  features/       →  他のfeatureを直接参照しない              │
│                     （共有が必要なら shared/ か entities/）  │
│                     infrastructure/ を使用可能               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  shared/         →  features に依存しない                    │
│  entities/       →  どこからでも参照可能                     │
│  infrastructure/ →  entities のみに依存                      │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 画面設計

### 3.1 画面レイアウト（縦画面・90度回転）

```
┌────────────────────────────────────────┐
│                                        │  ↑
│                                        │  │
│                                        │  │
│          メイン表示エリア               │  │
│           (上部 80%)                   │  │  画面高さ
│                                        │  │  (4K: 3840px)
│         選択された拠点の映像            │  │
│                                        │  │
│                            ┌────────┐  │  │
│                            │ 自分   │  │  │  セルフビュー
│                            │        │  │  │  (右下・小)
├────────────────────────────┴────────┴──┤  │
│  ┌────────┐  ┌────────┐  ┌────────┐   │  │
│  │ 拠点A  │  │ 拠点B  │  │ 拠点C  │   │  │  サブ表示
│  │        │  │        │  │        │   │  │  (下部 20%)
│  └────────┘  └────────┘  └────────┘   │  ↓
├────────────────────────────────────────┤
│  [🎤]  [📹]                            │  コントロール
└────────────────────────────────────────┘
         ← 画面幅 (4K: 2160px) →
```

### 3.2 2拠点接続時のレイアウト

```
┌────────────────────────────────────────┐
│                                        │
│                                        │
│                                        │
│                                        │
│          相手拠点の映像                 │
│           (100% フル表示)              │
│                                        │
│                                        │
│                            ┌────────┐  │
│                            │ 自分   │  │  セルフビュー
│                            │        │  │  (右下・小)
├────────────────────────────┴────────┴──┤
│  [🎤]  [📹]                            │
└────────────────────────────────────────┘
```

### 3.3 コンポーネント階層

```
VideoCallPage
├── VerticalLayout
│   ├── MainVideoDisplay
│   │   ├── VideoCanvas (メイン拠点映像)
│   │   └── SelfVideoDisplay (右下・小サイズ)
│   │       └── VideoElement (自分の映像)
│   ├── SubVideoDisplay (3拠点以上時のみ表示)
│   │   └── VideoGrid
│   │       └── VideoThumbnail[] (サブ拠点映像)
│   └── VideoControls
│       ├── MicrophoneButton
│       └── CameraButton
└── KeyboardShortcutHandler
```

### 3.4 セルフビュー仕様

| 項目 | 値 |
|------|-----|
| 位置 | メイン表示エリア右下 |
| サイズ | 画面幅の15%程度 |
| アスペクト比 | 16:9 |
| 表示条件 | カメラON時のみ表示 |
| z-index | メイン映像より上 |

---

## 4. 状態管理設計

### 4.1 AuthContext

```typescript
interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  company: Company | null;
  token: string | null;
  loading: boolean;
  error: string | null;
}

type AuthAction =
  | { type: 'LOGIN_START' }
  | { type: 'LOGIN_SUCCESS'; payload: { user: User; company: Company; token: string } }
  | { type: 'LOGIN_FAILURE'; payload: string }
  | { type: 'LOGOUT' };
```

### 4.2 VideoContext

```typescript
interface VideoState {
  sessionStatus: 'idle' | 'connecting' | 'connected' | 'disconnected';
  participants: Participant[];
  mainSiteId: string | null;
  localMedia: {
    isMicOn: boolean;
    isCameraOn: boolean;
  };
  volumeSettings: Record<string, number>;  // siteId -> volume (0-100)
  error: string | null;
}

type VideoAction =
  | { type: 'CONNECT_START' }
  | { type: 'CONNECT_SUCCESS'; payload: Participant[] }
  | { type: 'CONNECT_FAILURE'; payload: string }
  | { type: 'PARTICIPANT_JOIN'; payload: Participant }
  | { type: 'PARTICIPANT_LEAVE'; payload: string }
  | { type: 'SWITCH_MAIN_SITE'; payload: string }
  | { type: 'TOGGLE_MIC' }
  | { type: 'TOGGLE_CAMERA' }
  | { type: 'DISCONNECT' };
```

---

## 5. API設計

### 5.1 認証API

#### POST /api/auth/login
ユーザーログイン

**Request:**
```json
{
  "email": "user@example.com",
  "password": "password123"
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid",
      "name": "山田太郎",
      "email": "user@example.com",
      "siteId": "site-nagoya"
    },
    "company": {
      "id": "company-uuid",
      "name": "株式会社サンプル"
    },
    "accessToken": "eyJhbGciOiJIUzI1NiIs..."
  }
}
```

### 5.2 セッションAPI

#### POST /api/sessions/join
セッションに参加（Zoom JWT取得）

**Request:**
```json
{
  "siteId": "site-nagoya"
}
```

**Response (成功時):**
```json
{
  "success": true,
  "data": {
    "zoomJwt": "eyJhbGciOiJIUzI1NiIs...",
    "sessionTopic": "company-uuid-session",
    "userName": "名古屋",
    "sites": [
      { "id": "site-tokyo", "name": "東京", "isOnline": true },
      { "id": "site-osaka", "name": "大阪", "isOnline": true },
      { "id": "site-fukuoka", "name": "福岡", "isOnline": false }
    ],
    "operatingHours": {
      "endTime": "18:00",
      "remainingMinutes": 120,
      "warningThresholdMinutes": 5
    }
  }
}
```

**Response (稼働時間外エラー):**
```json
{
  "success": false,
  "error": {
    "code": "OUTSIDE_OPERATING_HOURS",
    "message": "現在は稼働時間外です",
    "details": {
      "currentTime": "19:30",
      "operatingHours": {
        "startTime": "09:00",
        "endTime": "18:00"
      },
      "nextOperatingDay": "2025-01-06",
      "nextStartTime": "09:00"
    }
  }
}
```

### 5.3 拠点API

#### GET /api/sites
会社の拠点一覧取得

**Response:**
```json
{
  "success": true,
  "data": {
    "sites": [
      { "id": "site-tokyo", "name": "東京", "displayOrder": 1 },
      { "id": "site-nagoya", "name": "名古屋", "displayOrder": 2 },
      { "id": "site-osaka", "name": "大阪", "displayOrder": 3 },
      { "id": "site-fukuoka", "name": "福岡", "displayOrder": 4 }
    ]
  }
}
```

### 5.4 稼働時間管理API

#### GET /api/schedules
稼働スケジュール一覧取得

**Response:**
```json
{
  "success": true,
  "data": {
    "schedules": [
      { "dayOfWeek": 0, "startTime": null, "endTime": null, "isEnabled": false },
      { "dayOfWeek": 1, "startTime": "09:00", "endTime": "18:00", "isEnabled": true },
      { "dayOfWeek": 2, "startTime": "09:00", "endTime": "18:00", "isEnabled": true },
      { "dayOfWeek": 3, "startTime": "09:00", "endTime": "18:00", "isEnabled": true },
      { "dayOfWeek": 4, "startTime": "09:00", "endTime": "18:00", "isEnabled": true },
      { "dayOfWeek": 5, "startTime": "09:00", "endTime": "18:00", "isEnabled": true },
      { "dayOfWeek": 6, "startTime": null, "endTime": null, "isEnabled": false }
    ],
    "exceptions": [
      { "date": "2025-01-01", "type": "holiday", "description": "元日" },
      { "date": "2025-03-15", "type": "custom", "startTime": "10:00", "endTime": "15:00", "description": "臨時稼働" }
    ],
    "timezone": "Asia/Tokyo"
  }
}
```

#### PUT /api/schedules
稼働スケジュール更新（管理者のみ）

**Request:**
```json
{
  "schedules": [
    { "dayOfWeek": 1, "startTime": "08:30", "endTime": "17:30", "isEnabled": true }
  ]
}
```

#### POST /api/schedules/exceptions
例外日の追加（管理者のみ）

**Request:**
```json
{
  "date": "2025-12-29",
  "type": "closed",
  "description": "年末休業"
}
```

#### GET /api/schedules/status
現在の稼働状態を取得

**Response:**
```json
{
  "success": true,
  "data": {
    "isOperating": true,
    "currentTime": "14:30",
    "todaySchedule": {
      "startTime": "09:00",
      "endTime": "18:00"
    },
    "remainingMinutes": 210,
    "warningThresholdMinutes": 5
  }
}
```

---

## 6. キーボードショートカット設計

| キー | 機能 |
|------|------|
| `1` | 1番目の拠点をメインに表示 |
| `2` | 2番目の拠点をメインに表示 |
| `3` | 3番目の拠点をメインに表示 |
| `4` | 4番目の拠点をメインに表示 |
| `M` | マイクのミュート切り替え |
| `V` | カメラのオン/オフ切り替え |
| `←` / `→` | メイン表示の前後切り替え |

---

## 7. 音量制御設計

### 7.1 音量レベル定数

```typescript
// config/constants.ts
export const VOLUME_LEVELS = {
  MAIN: 100,      // メイン拠点: 最大音量
  SUB: 30,        // サブ拠点: 30%音量
  MUTED: 0        // ミュート
} as const;
```

### 7.2 音量切り替えロジック

```typescript
// メイン拠点切り替え時の音量調整
const switchMainSite = (newMainSiteId: string) => {
  // 前のメイン拠点を低音量に
  if (currentMainSiteId) {
    zoomMediaStream.adjustUserVolume(currentMainSiteId, VOLUME_LEVELS.SUB);
  }

  // 新しいメイン拠点を高音量に
  zoomMediaStream.adjustUserVolume(newMainSiteId, VOLUME_LEVELS.MAIN);

  setMainSiteId(newMainSiteId);
};
```

---

## 8. 稼働時間管理設計

### 8.1 稼働時間チェックフロー

```
┌─────────────────────────────────────────────────────────────────┐
│                    セッション参加リクエスト                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│              operatingHoursMiddleware.ts                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 1. 会社IDからタイムゾーン取得                             │   │
│  │ 2. 現在日時を会社タイムゾーンで取得                        │   │
│  │ 3. 例外日（祝日・臨時休業）チェック                        │   │
│  │ 4. 通常スケジュールチェック                               │   │
│  │ 5. 稼働時間内 → next() / 時間外 → エラーレスポンス         │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
           ┌──────────────────┴──────────────────┐
           ▼                                     ▼
   ┌───────────────┐                    ┌───────────────┐
   │   稼働時間内   │                    │  稼働時間外   │
   │  セッション参加│                    │  エラー返却   │
   └───────────────┘                    └───────────────┘
```

### 8.2 稼働時間判定ロジック

```typescript
// application/services/OperatingHoursService.ts

interface OperatingStatus {
  isOperating: boolean;
  currentTime: string;
  todaySchedule: { startTime: string; endTime: string } | null;
  remainingMinutes: number | null;
  reason?: 'holiday' | 'closed' | 'outside_hours' | 'day_off';
}

class OperatingHoursService {
  async checkOperatingStatus(companyId: string): Promise<OperatingStatus> {
    const company = await this.companyRepository.findById(companyId);
    const now = this.getCurrentTimeInTimezone(company.timezone);
    const today = now.toISODate();
    const dayOfWeek = now.weekday % 7; // 0-6 (日曜=0)

    // 1. 例外日チェック（祝日・臨時休業・臨時稼働）
    const exception = await this.scheduleRepository.findException(companyId, today);
    if (exception) {
      return this.handleException(exception, now);
    }

    // 2. 通常スケジュールチェック
    const schedule = await this.scheduleRepository.findByDayOfWeek(companyId, dayOfWeek);
    if (!schedule?.isEnabled) {
      return { isOperating: false, reason: 'day_off', ... };
    }

    // 3. 時間範囲チェック
    return this.checkTimeRange(schedule, now);
  }
}
```

### 8.3 自動退出（キック）機能

```
┌─────────────────────────────────────────────────────────────────┐
│                     クライアント側                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              OperatingHoursMonitor                       │   │
│  │                                                          │   │
│  │  ┌──────────────────┐      ┌──────────────────────────┐ │   │
│  │  │ 残り時間カウント   │ ──▶ │ 5分前: 警告通知表示       │ │   │
│  │  │ (1分間隔でAPI確認) │      └──────────────────────────┘ │   │
│  │  └──────────────────┘                                    │   │
│  │           │                                              │   │
│  │           ▼                                              │   │
│  │  ┌──────────────────┐      ┌──────────────────────────┐ │   │
│  │  │ 残り0分到達       │ ──▶ │ 自動退出処理実行          │ │   │
│  │  └──────────────────┘      │ ・Zoomセッション離脱      │ │   │
│  │                            │ ・終了画面へ遷移          │ │   │
│  │                            └──────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 8.4 フロントエンド実装

```typescript
// presentation/hooks/useOperatingHoursMonitor.ts

const POLLING_INTERVAL_MS = 60000;  // 1分間隔
const WARNING_THRESHOLD_MINUTES = 5;

export const useOperatingHoursMonitor = () => {
  const [remainingMinutes, setRemainingMinutes] = useState<number | null>(null);
  const [showWarning, setShowWarning] = useState(false);
  const { disconnect } = useVideoContext();

  useEffect(() => {
    const checkStatus = async () => {
      const status = await operatingHoursApi.getStatus();

      if (!status.isOperating) {
        // 稼働時間外になった → 強制退出
        await disconnect();
        navigate('/session-ended', { reason: 'operating_hours_ended' });
        return;
      }

      setRemainingMinutes(status.remainingMinutes);

      // 警告表示
      if (status.remainingMinutes <= WARNING_THRESHOLD_MINUTES) {
        setShowWarning(true);
      }
    };

    const interval = setInterval(checkStatus, POLLING_INTERVAL_MS);
    checkStatus(); // 初回即時実行

    return () => clearInterval(interval);
  }, []);

  return { remainingMinutes, showWarning };
};
```

### 8.5 警告通知コンポーネント

```typescript
// presentation/components/OperatingHoursWarning.tsx

const OperatingHoursWarning: React.FC<{ remainingMinutes: number }> = ({
  remainingMinutes
}) => {
  if (remainingMinutes > WARNING_THRESHOLD_MINUTES) {
    return null;
  }

  return (
    <div className="operating-hours-warning">
      <span>稼働終了まで残り {remainingMinutes} 分です</span>
      <span>終了時刻になると自動的に通話が終了します</span>
    </div>
  );
};
```

### 8.6 定数定義

```typescript
// config/constants.ts

export const OPERATING_HOURS = {
  POLLING_INTERVAL_MS: 60000,         // 状態確認間隔（1分）
  WARNING_THRESHOLD_MINUTES: 5,        // 警告表示の閾値（終了5分前）
  GRACE_PERIOD_SECONDS: 30,           // 終了後の猶予時間（30秒）
} as const;

export const DAY_OF_WEEK = {
  SUNDAY: 0,
  MONDAY: 1,
  TUESDAY: 2,
  WEDNESDAY: 3,
  THURSDAY: 4,
  FRIDAY: 5,
  SATURDAY: 6,
} as const;
```

---

## 9. セキュリティ設計

### 9.1 認証アーキテクチャ概要

本アプリケーションでは**2種類のJWT**を使用します。

| JWT種別 | 用途 | 発行者 | 有効期限 | 秘密鍵 |
|---------|------|--------|---------|--------|
| **アプリ認証JWT** | ユーザーのログイン状態管理 | 自社サーバー | 24時間 | `JWT_SECRET` |
| **Zoom SDK JWT** | ビデオ通話セッション参加 | 自社サーバー | 2時間 | `ZOOM_SDK_SECRET` |

```
┌─────────────────────────────────────────────────────────────────┐
│                        認証フロー全体図                          │
└─────────────────────────────────────────────────────────────────┘

     フロント                    サーバー                   Zoom
        │                          │                        │
        │  1. POST /auth/login     │                        │
        │  {email, password}       │                        │
        │ ─────────────────────▶   │                        │
        │                          │                        │
        │  アプリJWT               │                        │
        │ ◀─────────────────────   │                        │
        │                          │                        │
        │  2. POST /sessions/join  │                        │
        │  Authorization: Bearer   │                        │
        │ ─────────────────────▶   │                        │
        │                          │ ・アプリJWT検証         │
        │                          │ ・companyIdで会社特定   │
        │                          │ ・稼働時間チェック      │
        │                          │ ・Zoom JWT生成         │
        │  Zoom SDK JWT            │                        │
        │ ◀─────────────────────   │                        │
        │                          │                        │
        │  3. ZoomClient.join()    │                        │
        │ ─────────────────────────────────────────────────▶│
        │                          │                        │
        │  WebSocket確立           │                        │
        │ ◀─────────────────────────────────────────────────│
        │                          │                        │
```

---

### 9.2 アプリ認証JWT（ユーザーログイン用）

#### 9.2.1 JWTペイロード構造

```typescript
// server/shared/lib/jwt.ts

interface AppJwtPayload {
  sub: string;        // ユーザーID
  companyId: string;  // 会社ID（マルチテナント識別）
  siteId: string;     // 所属拠点ID
  role: 'admin' | 'user';
  iat: number;        // 発行時刻 (issued at)
  exp: number;        // 有効期限 (expiration)
}
```

#### 9.2.2 JWT生成・検証

```typescript
// server/shared/lib/jwt.ts

import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';

// JWT生成
export const generateAppToken = (user: {
  id: string;
  companyId: string;
  siteId: string;
  role: 'admin' | 'user';
}): string => {
  return jwt.sign(
    {
      sub: user.id,
      companyId: user.companyId,
      siteId: user.siteId,
      role: user.role,
    },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES_IN }
  );
};

// JWT検証
export const verifyAppToken = (token: string): AppJwtPayload => {
  return jwt.verify(token, JWT_SECRET) as AppJwtPayload;
};

// トークンからペイロード取得（検証なし・デバッグ用）
export const decodeToken = (token: string): AppJwtPayload | null => {
  return jwt.decode(token) as AppJwtPayload | null;
};
```

#### 9.2.3 認証ミドルウェア

```typescript
// server/shared/middleware/authMiddleware.ts

import { Request, Response, NextFunction } from 'express';
import { verifyAppToken } from '../lib/jwt';
import { AuthenticationError } from '../errors';

// リクエストにユーザー情報を付与するための型拡張
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        companyId: string;
        siteId: string;
        role: 'admin' | 'user';
      };
    }
  }
}

export const authMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;

    // Bearerトークンの存在確認
    if (!authHeader?.startsWith('Bearer ')) {
      throw new AuthenticationError('認証トークンが必要です');
    }

    const token = authHeader.slice(7); // 'Bearer ' を除去

    // JWT検証
    const payload = verifyAppToken(token);

    // リクエストにユーザー情報を付与
    req.user = {
      id: payload.sub,
      companyId: payload.companyId,
      siteId: payload.siteId,
      role: payload.role,
    };

    next();
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      res.status(401).json({
        success: false,
        error: { code: 'TOKEN_EXPIRED', message: 'トークンの有効期限が切れています' }
      });
      return;
    }
    if (error instanceof jwt.JsonWebTokenError) {
      res.status(401).json({
        success: false,
        error: { code: 'INVALID_TOKEN', message: '無効なトークンです' }
      });
      return;
    }
    next(error);
  }
};

// 管理者権限チェックミドルウェア
export const adminOnlyMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  if (req.user?.role !== 'admin') {
    res.status(403).json({
      success: false,
      error: { code: 'FORBIDDEN', message: '管理者権限が必要です' }
    });
    return;
  }
  next();
};
```

#### 9.2.4 ログインUseCase

```typescript
// server/features/auth/usecases/LoginUseCase.ts

import bcrypt from 'bcrypt';
import { generateAppToken } from '@/shared/lib/jwt';
import { AuthenticationError } from '@/shared/errors';

interface LoginInput {
  email: string;
  password: string;
}

interface LoginOutput {
  user: {
    id: string;
    name: string;
    email: string;
    siteId: string;
    role: 'admin' | 'user';
  };
  company: {
    id: string;
    name: string;
  };
  accessToken: string;
}

export class LoginUseCase {
  constructor(private userRepository: UserRepository) {}

  async execute(input: LoginInput): Promise<LoginOutput> {
    // 1. ユーザー検索
    const user = await this.userRepository.findByEmail(input.email);
    if (!user) {
      throw new AuthenticationError('メールアドレスまたはパスワードが正しくありません');
    }

    // 2. パスワード検証
    const isPasswordValid = await bcrypt.compare(input.password, user.passwordHash);
    if (!isPasswordValid) {
      throw new AuthenticationError('メールアドレスまたはパスワードが正しくありません');
    }

    // 3. JWT生成
    const accessToken = generateAppToken({
      id: user.id,
      companyId: user.companyId,
      siteId: user.siteId,
      role: user.role,
    });

    // 4. レスポンス返却
    return {
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        siteId: user.siteId,
        role: user.role,
      },
      company: {
        id: user.company.id,
        name: user.company.name,
      },
      accessToken,
    };
  }
}
```

---

### 9.3 Zoom SDK JWT（ビデオ通話用）

#### 9.3.1 Zoom SDK JWTペイロード構造

```typescript
// Zoom Video SDK が要求するJWTペイロード形式
interface ZoomSdkJwtPayload {
  app_key: string;       // Zoom SDK Key
  tpc: string;           // topic（セッション識別子）
  role_type: number;     // 0: 参加者, 1: ホスト
  user_identity: string; // ユーザー識別子
  version: number;       // 固定値: 1
  iat: number;           // 発行時刻
  exp: number;           // 有効期限
}
```

#### 9.3.2 Zoom JWT生成サービス

```typescript
// server/features/session/services/ZoomJwtService.ts

import jwt from 'jsonwebtoken';

interface GenerateTokenParams {
  topic: string;
  userId: string;
  role: 'host' | 'participant';
}

export class ZoomJwtService {
  private readonly sdkKey: string;
  private readonly sdkSecret: string;
  private readonly expiresIn: number; // 秒

  constructor() {
    this.sdkKey = process.env.ZOOM_SDK_KEY!;
    this.sdkSecret = process.env.ZOOM_SDK_SECRET!;
    this.expiresIn = parseInt(process.env.ZOOM_JWT_EXPIRES_IN || '7200', 10);

    // 環境変数の検証
    if (!this.sdkKey || !this.sdkSecret) {
      throw new Error('ZOOM_SDK_KEY and ZOOM_SDK_SECRET must be set');
    }
  }

  generateToken(params: GenerateTokenParams): string {
    const iat = Math.floor(Date.now() / 1000);
    const exp = iat + this.expiresIn;

    const payload = {
      app_key: this.sdkKey,
      tpc: params.topic,
      role_type: params.role === 'host' ? 1 : 0,
      user_identity: params.userId,
      version: 1,
      iat,
      exp,
    };

    return jwt.sign(payload, this.sdkSecret, { algorithm: 'HS256' });
  }
}
```

#### 9.3.3 セッション参加UseCase

```typescript
// server/features/session/usecases/JoinSessionUseCase.ts

import { ZoomJwtService } from '../services/ZoomJwtService';
import { OperatingHoursService } from '@/features/operating-hours';
import { OutsideOperatingHoursError } from '@/shared/errors';

interface JoinSessionInput {
  userId: string;
  companyId: string;
  siteId: string;
  siteName: string;
}

interface JoinSessionOutput {
  zoomJwt: string;
  sessionTopic: string;
  userName: string;
  operatingHours: {
    endTime: string | null;
    remainingMinutes: number | null;
    warningThresholdMinutes: number;
  };
}

export class JoinSessionUseCase {
  constructor(
    private zoomJwtService: ZoomJwtService,
    private sessionRepository: SessionRepository,
    private operatingHoursService: OperatingHoursService
  ) {}

  async execute(input: JoinSessionInput): Promise<JoinSessionOutput> {
    // 1. 稼働時間チェック
    const operatingStatus = await this.operatingHoursService
      .checkOperatingStatus(input.companyId);

    if (!operatingStatus.isOperating) {
      throw new OutsideOperatingHoursError({
        currentTime: operatingStatus.currentTime,
        reason: operatingStatus.reason,
        nextOperatingDay: operatingStatus.nextOperatingDay,
      });
    }

    // 2. セッショントピック生成（会社ごとに一意）
    const sessionTopic = this.generateSessionTopic(input.companyId);

    // 3. Zoom SDK JWT生成
    const zoomJwt = this.zoomJwtService.generateToken({
      topic: sessionTopic,
      userId: input.userId,
      role: 'participant', // 全員participantで参加
    });

    // 4. セッション参加記録
    await this.sessionRepository.recordParticipantJoin({
      companyId: input.companyId,
      siteId: input.siteId,
      userId: input.userId,
      topic: sessionTopic,
    });

    // 5. 結果返却
    return {
      zoomJwt,
      sessionTopic,
      userName: input.siteName,
      operatingHours: {
        endTime: operatingStatus.todaySchedule?.endTime ?? null,
        remainingMinutes: operatingStatus.remainingMinutes,
        warningThresholdMinutes: 5,
      },
    };
  }

  private generateSessionTopic(companyId: string): string {
    // 会社ごとに固定のtopicを使用（常設セッション）
    return `${companyId}-video-session`;
  }
}
```

---

### 9.4 マルチテナント分離

#### 9.4.1 分離の仕組み

```
┌─────────────────────────────────────────────────────────────────┐
│                      マルチテナント分離                          │
└─────────────────────────────────────────────────────────────────┘

  会社A (companyId: aaa-111)          会社B (companyId: bbb-222)
  ┌─────────────────────┐            ┌─────────────────────┐
  │                     │            │                     │
  │  Topic:             │            │  Topic:             │
  │  aaa-111-video-     │            │  bbb-222-video-     │
  │  session            │            │  session            │
  │                     │            │                     │
  │  ┌───┐ ┌───┐ ┌───┐  │            │  ┌───┐ ┌───┐       │
  │  │東京│ │大阪│ │福岡│  │            │  │本社│ │支社│       │
  │  └───┘ └───┘ └───┘  │            │  └───┘ └───┘       │
  │                     │            │                     │
  └─────────────────────┘            └─────────────────────┘
          │                                  │
          │ 相互アクセス不可                   │
          └──────────────────────────────────┘
```

#### 9.4.2 分離ポイント

| レイヤー | 分離方法 |
|----------|----------|
| **アプリJWT** | `companyId` をペイロードに含める |
| **APIアクセス** | ミドルウェアで `req.user.companyId` を検証 |
| **Zoom SDK JWT** | `topic` に `companyId` を含める |
| **データベース** | 全クエリで `companyId` 条件を付与 |
| **RLS** | Supabaseの Row Level Security で強制 |

#### 9.4.3 会社間アクセス防止ミドルウェア

```typescript
// server/shared/middleware/companyIsolationMiddleware.ts

export const companyIsolationMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // リクエストボディやパラメータのcompanyIdと
  // JWTのcompanyIdが一致することを確認
  const requestedCompanyId = req.body.companyId || req.params.companyId;
  const userCompanyId = req.user?.companyId;

  if (requestedCompanyId && requestedCompanyId !== userCompanyId) {
    res.status(403).json({
      success: false,
      error: {
        code: 'COMPANY_MISMATCH',
        message: '他社のリソースにはアクセスできません'
      }
    });
    return;
  }

  next();
};
```

---

### 9.5 フロントエンド認証実装

#### 9.5.1 トークン管理

```typescript
// front/features/auth/lib/tokenStorage.ts

const ACCESS_TOKEN_KEY = 'access_token';

export const tokenStorage = {
  get: (): string | null => {
    return localStorage.getItem(ACCESS_TOKEN_KEY);
  },

  set: (token: string): void => {
    localStorage.setItem(ACCESS_TOKEN_KEY, token);
  },

  remove: (): void => {
    localStorage.removeItem(ACCESS_TOKEN_KEY);
  },

  // トークンの有効期限チェック
  isExpired: (): boolean => {
    const token = tokenStorage.get();
    if (!token) return true;

    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload.exp * 1000 < Date.now();
    } catch {
      return true;
    }
  },
};
```

#### 9.5.2 APIクライアント

```typescript
// front/shared/lib/apiClient.ts

import { tokenStorage } from '@/features/auth/lib/tokenStorage';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;

interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
  };
}

export const apiClient = {
  async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const token = tokenStorage.get();

    const headers: HeadersInit = {
      'Content-Type': 'application/json',
      ...options.headers,
    };

    // トークンがあれば Authorization ヘッダーを追加
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      ...options,
      headers,
    });

    // 401エラーの場合はトークンをクリアしてログインページへ
    if (response.status === 401) {
      tokenStorage.remove();
      window.location.href = '/login';
      throw new Error('認証が必要です');
    }

    return response.json();
  },

  get<T>(endpoint: string): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, { method: 'GET' });
  },

  post<T>(endpoint: string, body: unknown): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(body),
    });
  },

  put<T>(endpoint: string, body: unknown): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, {
      method: 'PUT',
      body: JSON.stringify(body),
    });
  },

  delete<T>(endpoint: string): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, { method: 'DELETE' });
  },
};
```

#### 9.5.3 認証コンテキスト

```typescript
// front/features/auth/context/AuthContext.tsx

import { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';
import { tokenStorage } from '../lib/tokenStorage';
import { apiClient } from '@/shared/lib/apiClient';

interface User {
  id: string;
  name: string;
  email: string;
  siteId: string;
  role: 'admin' | 'user';
}

interface Company {
  id: string;
  name: string;
}

interface AuthState {
  isAuthenticated: boolean;
  isLoading: boolean;
  user: User | null;
  company: Company | null;
  error: string | null;
}

type AuthAction =
  | { type: 'AUTH_START' }
  | { type: 'AUTH_SUCCESS'; payload: { user: User; company: Company } }
  | { type: 'AUTH_FAILURE'; payload: string }
  | { type: 'LOGOUT' };

const authReducer = (state: AuthState, action: AuthAction): AuthState => {
  switch (action.type) {
    case 'AUTH_START':
      return { ...state, isLoading: true, error: null };
    case 'AUTH_SUCCESS':
      return {
        ...state,
        isLoading: false,
        isAuthenticated: true,
        user: action.payload.user,
        company: action.payload.company,
      };
    case 'AUTH_FAILURE':
      return {
        ...state,
        isLoading: false,
        isAuthenticated: false,
        error: action.payload,
      };
    case 'LOGOUT':
      return {
        isAuthenticated: false,
        isLoading: false,
        user: null,
        company: null,
        error: null,
      };
    default:
      return state;
  }
};

interface AuthContextValue extends AuthState {
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextValue | null>(null);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [state, dispatch] = useReducer(authReducer, {
    isAuthenticated: false,
    isLoading: true,
    user: null,
    company: null,
    error: null,
  });

  // 初期化時にトークン検証
  useEffect(() => {
    const initAuth = async () => {
      if (tokenStorage.isExpired()) {
        tokenStorage.remove();
        dispatch({ type: 'LOGOUT' });
        return;
      }

      try {
        // トークンが有効ならユーザー情報を取得
        const response = await apiClient.get<{ user: User; company: Company }>(
          '/auth/me'
        );
        if (response.success && response.data) {
          dispatch({ type: 'AUTH_SUCCESS', payload: response.data });
        } else {
          dispatch({ type: 'LOGOUT' });
        }
      } catch {
        dispatch({ type: 'LOGOUT' });
      }
    };

    initAuth();
  }, []);

  const login = async (email: string, password: string) => {
    dispatch({ type: 'AUTH_START' });

    try {
      const response = await apiClient.post<{
        user: User;
        company: Company;
        accessToken: string;
      }>('/auth/login', { email, password });

      if (response.success && response.data) {
        tokenStorage.set(response.data.accessToken);
        dispatch({
          type: 'AUTH_SUCCESS',
          payload: {
            user: response.data.user,
            company: response.data.company,
          },
        });
      } else {
        dispatch({
          type: 'AUTH_FAILURE',
          payload: response.error?.message || 'ログインに失敗しました',
        });
      }
    } catch (error) {
      dispatch({
        type: 'AUTH_FAILURE',
        payload: 'ログインに失敗しました',
      });
    }
  };

  const logout = () => {
    tokenStorage.remove();
    dispatch({ type: 'LOGOUT' });
  };

  return (
    <AuthContext.Provider value={{ ...state, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextValue => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

---

### 9.6 セキュリティ対策一覧

| 対策 | 実装方法 | 対象 |
|------|----------|------|
| **HTTPS強制** | Helmet middleware (`hsts`) | サーバー |
| **CORS制限** | 許可オリジンのみ設定 | サーバー |
| **XSS対策** | Helmet middleware (`contentSecurityPolicy`) | サーバー |
| **CSRF対策** | SameSite Cookie + Origin検証 | サーバー |
| **レート制限** | express-rate-limit | サーバー |
| **入力検証** | Zod スキーマ検証 | サーバー |
| **SQLインジェクション対策** | Prisma ORM（パラメータ化クエリ） | サーバー |
| **JWT有効期限** | アプリJWT: 24h, Zoom JWT: 2h | サーバー |
| **パスワードハッシュ** | bcrypt (cost=10) | サーバー |
| **機密情報保護** | 環境変数で管理、フロントに露出しない | 両方 |

### 9.7 環境変数（認証関連）

```bash
# server/.env

# アプリ認証JWT
JWT_SECRET="your-secure-random-string-at-least-32-chars"
JWT_EXPIRES_IN="24h"

# Zoom SDK認証
ZOOM_SDK_KEY="your-zoom-sdk-key"
ZOOM_SDK_SECRET="your-zoom-sdk-secret"
ZOOM_JWT_EXPIRES_IN="7200"  # 2時間（秒）
```

> **重要**: `JWT_SECRET` と `ZOOM_SDK_SECRET` は十分な長さ（32文字以上）のランダムな文字列を使用してください。

---

## 10. エラーハンドリング設計

### 10.1 カスタム例外クラス

```typescript
// domain/errors/AppError.ts
abstract class AppError extends Error {
  abstract readonly statusCode: number;
  abstract readonly isOperational: boolean;
}

class AuthenticationError extends AppError {
  readonly statusCode = 401;
  readonly isOperational = true;
}

class AuthorizationError extends AppError {
  readonly statusCode = 403;
  readonly isOperational = true;
}

class NotFoundError extends AppError {
  readonly statusCode = 404;
  readonly isOperational = true;
}

class VideoConnectionError extends AppError {
  readonly statusCode = 500;
  readonly isOperational = true;
}
```

### 10.2 フロントエンドエラーハンドリング

```typescript
// Zoom SDK接続エラー時のリトライ戦略
const MAX_RETRY_COUNT = 3;
const RETRY_DELAY_MS = 2000;

const connectWithRetry = async (retryCount = 0): Promise<void> => {
  try {
    await zoomClient.join(topic, token, userName);
  } catch (error) {
    if (retryCount < MAX_RETRY_COUNT) {
      await delay(RETRY_DELAY_MS);
      return connectWithRetry(retryCount + 1);
    }
    throw new VideoConnectionError('接続に失敗しました');
  }
};
```

---

## 11. テスト戦略

### 11.1 テストピラミッド

```
        /\
       /  \       E2E テスト (少数)
      /    \      - 主要ユーザーフロー
     /──────\
    /        \    統合テスト (中程度)
   /          \   - API エンドポイント
  /────────────\  - コンポーネント連携
 /              \
/                \ ユニットテスト (多数)
──────────────────  - ドメインロジック
                    - ユースケース
                    - ユーティリティ関数
```

### 11.2 TDDサイクル

```
1. Red: 失敗するテストを書く
   ↓
2. Green: テストが通る最小限のコードを書く
   ↓
3. Refactor: コードを改善（テストは通ったまま）
   ↓
1. に戻る
```

### 11.3 テスト対象

| レイヤー | テスト対象 | ツール |
|---------|-----------|--------|
| Domain | エンティティ、値オブジェクト | Vitest |
| Application | ユースケース | Vitest + Mock |
| Presentation | コンポーネント | Testing Library |
| Infrastructure | リポジトリ | Vitest + Prisma Mock |
| E2E | ユーザーフロー | Playwright |

---

## 12. 今後の拡張性

### 12.1 機能拡張ポイント

| 機能 | 拡張方法 |
|------|---------|
| 4K対応 | VideoQuality.Video_4K 使用 |
| 拠点追加 | DB登録のみで対応可能 |
| 録画機能 | Zoom SDK RecordingClient 使用 |
| 画面共有 | Zoom SDK Share機能 使用 |
| チャット | Zoom SDK ChatClient 使用 |

### 12.2 スケーリング

- フロントエンド: CDN配信
- バックエンド: 水平スケーリング対応（ステートレス設計）
- データベース: Supabaseのスケーリング機能活用
