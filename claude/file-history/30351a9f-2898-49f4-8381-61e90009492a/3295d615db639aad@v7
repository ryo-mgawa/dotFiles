# 拠点間ビデオ通話Webアプリケーション 設計書

## 1. システム概要

### 1.1 システム構成図

```
┌─────────────────────────────────────────────────────────────────┐
│                        クライアント                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              React SPA (front/)                          │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │   │
│  │  │ Presentation│  │ Application │  │    Domain       │  │   │
│  │  │    Layer    │──│    Layer    │──│    Layer        │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ HTTPS/WebSocket
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        サーバー                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Node.js/Express (server/)                   │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │   │
│  │  │ Presentation│  │ Application │  │ Infrastructure  │  │   │
│  │  │  (Routes)   │──│  (UseCases) │──│ (Repository)    │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────┐    ┌──────────────────┐
│    Supabase      │    │   Zoom Video     │
│   (PostgreSQL)   │    │      SDK         │
└──────────────────┘    └──────────────────┘
```

### 1.2 技術スタック

| カテゴリ | 技術 | バージョン |
|---------|------|-----------|
| フロントエンド | React | 18.x (最新安定版) |
| フロントエンド | TypeScript | 5.x (最新安定版) |
| フロントエンド | Vite | 5.x (最新安定版) |
| フロントエンド | React Router | 6.x (最新安定版) |
| バックエンド | Node.js | 20.x LTS |
| バックエンド | Express | 4.x (最新安定版) |
| バックエンド | TypeScript | 5.x (最新安定版) |
| ORM | Prisma | 5.x (最新安定版) |
| データベース | Supabase (PostgreSQL) | - |
| ビデオ通話 | Zoom Video SDK | 2.3.5 |
| テスト | Vitest | 1.x (最新安定版) |
| テスト | Testing Library | 14.x (最新安定版) |

### 1.3 環境変数設計

#### 1.3.1 バックエンド環境変数

```bash
# server/.env

# Database
DATABASE_URL="postgresql://user:password@host:5432/dbname"

# JWT (アプリケーション認証用)
JWT_SECRET="your-jwt-secret-key"
JWT_EXPIRES_IN="24h"

# Zoom Video SDK (運営側で1アカウント管理)
ZOOM_SDK_KEY="your-zoom-sdk-key"
ZOOM_SDK_SECRET="your-zoom-sdk-secret"
ZOOM_JWT_EXPIRES_IN="7200"  # 秒（2時間）

# Server
PORT="3001"
NODE_ENV="development"
CORS_ORIGIN="http://localhost:5173"

# Operating Hours
WARNING_THRESHOLD_MINUTES="5"
```

#### 1.3.2 フロントエンド環境変数

```bash
# front/.env

VITE_API_BASE_URL="http://localhost:3001/api"
VITE_ZOOM_WEB_ENDPOINT="zoom.us"
```

#### 1.3.3 環境変数の管理方針

| 項目 | 方針 |
|------|------|
| 本番環境 | 環境変数は外部シークレット管理サービスで管理 |
| 開発環境 | `.env.local` を使用（Git管理対象外） |
| サンプル | `.env.example` をリポジトリに含める |
| SDK認証情報 | `ZOOM_SDK_KEY` / `ZOOM_SDK_SECRET` はバックエンドのみで使用 |
| フロントエンド | SDK Secretは絶対に公開しない（JWTのみ使用） |

#### 1.3.4 Zoom SDK認証フロー

```
┌─────────────────────────────────────────────────────────────────┐
│  環境変数                                                        │
│  ZOOM_SDK_KEY, ZOOM_SDK_SECRET                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  サーバー (ZoomJwtService.ts)                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 1. SDK Key/Secret を環境変数から読み込み                    │   │
│  │ 2. セッション参加時にZoom SDK JWT生成                       │   │
│  │    - topic: {companyId}-video-session (会社分離)           │   │
│  │    - role: 1 (host) または 0 (participant)                 │   │
│  │    - 有効期限: 2時間                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ JWT トークン
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  クライアント (ZoomClient.ts)                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 1. サーバーからZoom SDK JWTを受け取る                       │   │
│  │ 2. ZoomClient.init() で初期化                              │   │
│  │ 3. ZoomClient.join(topic, jwt, userName) で接続            │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

> **Note**: Zoom SDK Key/Secretは運営側で1つのアカウントとして管理し、会社ごとに異なるtopicを使用することでマルチテナント分離を実現します。

### 1.4 デザインパターン

本アプリケーションでは以下のデザインパターンを採用し、保守性・拡張性・テスタビリティを向上させます。

#### 1.4.1 Observer Pattern（参加者状態・稼働時間監視）

参加者の入退室や稼働時間の変化を、関心のあるコンポーネントに通知します。

```
┌─────────────────────────────────────────────────────────────────┐
│                      Subject (Observable)                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              VideoSessionSubject                         │   │
│  │  - observers: Set<VideoSessionObserver>                  │   │
│  │  - participants: Participant[]                           │   │
│  │  + subscribe(observer): void                             │   │
│  │  + unsubscribe(observer): void                           │   │
│  │  + notify(event): void                                   │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ notify
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Observers (Subscribers)                       │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────────┐   │
│  │ VideoGrid     │  │ VolumeManager │  │ ParticipantCount  │   │
│  │ Observer      │  │ Observer      │  │ Observer          │   │
│  └───────────────┘  └───────────────┘  └───────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

**実装:**

```typescript
// features/video-call/observers/VideoSessionObserver.ts

interface VideoSessionEvent {
  type: 'PARTICIPANT_JOIN' | 'PARTICIPANT_LEAVE' | 'PARTICIPANT_UPDATE';
  participant: Participant;
  timestamp: Date;
}

interface VideoSessionObserver {
  onSessionEvent(event: VideoSessionEvent): void;
}

// features/video-call/observers/VideoSessionSubject.ts

class VideoSessionSubject {
  private observers: Set<VideoSessionObserver> = new Set();

  subscribe(observer: VideoSessionObserver): () => void {
    this.observers.add(observer);
    return () => this.unsubscribe(observer);
  }

  unsubscribe(observer: VideoSessionObserver): void {
    this.observers.delete(observer);
  }

  notify(event: VideoSessionEvent): void {
    this.observers.forEach(observer => observer.onSessionEvent(event));
  }
}
```

**稼働時間監視への適用:**

```typescript
// features/operating-hours/observers/OperatingHoursObserver.ts

interface OperatingHoursEvent {
  type: 'WARNING' | 'EXPIRED' | 'STATUS_CHANGE';
  remainingMinutes: number;
  message: string;
}

interface OperatingHoursObserver {
  onOperatingHoursEvent(event: OperatingHoursEvent): void;
}

// 使用例: 複数コンポーネントが稼働時間の変化を購読
class WarningNotificationObserver implements OperatingHoursObserver {
  onOperatingHoursEvent(event: OperatingHoursEvent): void {
    if (event.type === 'WARNING') {
      showNotification(event.message);
    }
  }
}

class AutoDisconnectObserver implements OperatingHoursObserver {
  constructor(private disconnectFn: () => Promise<void>) {}

  onOperatingHoursEvent(event: OperatingHoursEvent): void {
    if (event.type === 'EXPIRED') {
      this.disconnectFn();
    }
  }
}
```

---

#### 1.4.2 Facade Pattern（Zoom SDK操作の簡略化）

複雑なZoom SDKのAPIを、アプリケーション固有のシンプルなインターフェースで隠蔽します。

```
┌─────────────────────────────────────────────────────────────────┐
│                        Client Code                               │
│                   (VideoCallPage, UseCases)                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 簡潔なAPI呼び出し
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     ZoomVideoFacade                              │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  + joinSession(config: SessionConfig): Promise<void>     │   │
│  │  + leaveSession(): Promise<void>                         │   │
│  │  + toggleMicrophone(): Promise<boolean>                  │   │
│  │  + toggleCamera(): Promise<boolean>                      │   │
│  │  + setParticipantVolume(id, level): Promise<void>        │   │
│  │  + switchMainDisplay(siteId): void                       │   │
│  │  + getParticipants(): Participant[]                      │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 内部で複雑な操作を実行
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Zoom SDK Subsystems                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │ ZoomVideo    │  │ MediaStream  │  │ Participant          │  │
│  │ Client       │  │              │  │ Manager              │  │
│  ├──────────────┤  ├──────────────┤  ├──────────────────────┤  │
│  │ init()       │  │ startAudio() │  │ getAllUser()         │  │
│  │ join()       │  │ startVideo() │  │ getUser()            │  │
│  │ leave()      │  │ stopAudio()  │  │ adjustUserVolume()   │  │
│  │ on()         │  │ stopVideo()  │  │ renderVideo()        │  │
│  │ off()        │  │ muteAudio()  │  │ stopRenderVideo()    │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

**実装:**

```typescript
// features/video-call/facade/ZoomVideoFacade.ts

interface SessionConfig {
  topic: string;
  token: string;
  userName: string;
  videoQuality?: VideoQuality;
}

class ZoomVideoFacade {
  private client: typeof ZoomVideo;
  private mediaStream: MediaStream | null = null;
  private sessionSubject: VideoSessionSubject;

  constructor(sessionSubject: VideoSessionSubject) {
    this.client = ZoomVideo.createClient();
    this.sessionSubject = sessionSubject;
  }

  async joinSession(config: SessionConfig): Promise<void> {
    await this.client.init('en-US', 'Global', { patchJsMedia: true });
    await this.client.join(config.topic, config.token, config.userName);
    this.mediaStream = this.client.getMediaStream();
    this.setupEventListeners();
  }

  async leaveSession(): Promise<void> {
    await this.client.leave();
    this.mediaStream = null;
  }

  async toggleMicrophone(): Promise<boolean> {
    if (!this.mediaStream) throw new Error('Not connected');

    const isCurrentlyMuted = this.mediaStream.isAudioMuted();
    if (isCurrentlyMuted) {
      await this.mediaStream.unmuteAudio();
    } else {
      await this.mediaStream.muteAudio();
    }
    return !isCurrentlyMuted;
  }

  async toggleCamera(): Promise<boolean> {
    if (!this.mediaStream) throw new Error('Not connected');

    const isCapturing = this.mediaStream.isCapturingVideo();
    if (isCapturing) {
      await this.mediaStream.stopVideo();
    } else {
      await this.mediaStream.startVideo({ videoQuality: VideoQuality.Video_1080P });
    }
    return !isCapturing;
  }

  async setParticipantVolume(participantId: string, volume: number): Promise<void> {
    if (!this.mediaStream) throw new Error('Not connected');
    await this.mediaStream.adjustUserAudioVolumeLocally(participantId, volume);
  }

  private setupEventListeners(): void {
    this.client.on('user-added', (participants) => {
      participants.forEach(p => {
        this.sessionSubject.notify({
          type: 'PARTICIPANT_JOIN',
          participant: this.mapToParticipant(p),
          timestamp: new Date()
        });
      });
    });

    this.client.on('user-removed', (participants) => {
      participants.forEach(p => {
        this.sessionSubject.notify({
          type: 'PARTICIPANT_LEAVE',
          participant: this.mapToParticipant(p),
          timestamp: new Date()
        });
      });
    });
  }

  private mapToParticipant(sdkUser: ZoomParticipant): Participant {
    return {
      id: String(sdkUser.oderId),
      name: sdkUser.displayName,
      isVideoOn: sdkUser.bVideoOn,
      isAudioOn: !sdkUser.muted
    };
  }
}
```

---

#### 1.4.3 Adapter Pattern（SDK依存の分離）

Zoom SDKへの依存をアプリケーション層から分離し、テスタビリティと将来のSDK変更への耐性を確保します。

```
┌─────────────────────────────────────────────────────────────────┐
│                     Application Layer                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   JoinSessionUseCase                     │   │
│  │  - videoService: IVideoService  ← インターフェースに依存   │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ 依存性の逆転
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Domain Layer (Interface)                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    IVideoService                         │   │
│  │  + connect(config): Promise<void>                        │   │
│  │  + disconnect(): Promise<void>                           │   │
│  │  + toggleAudio(): Promise<boolean>                       │   │
│  │  + toggleVideo(): Promise<boolean>                       │   │
│  │  + setVolume(participantId, level): Promise<void>        │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              ▲
                              │ 実装
          ┌───────────────────┴───────────────────┐
          │                                       │
┌─────────────────────┐               ┌─────────────────────┐
│ ZoomVideoAdapter    │               │ MockVideoAdapter    │
│ (本番用)             │               │ (テスト用)           │
├─────────────────────┤               ├─────────────────────┤
│ - facade: Zoom      │               │ - state: MockState  │
│   VideoFacade       │               │                     │
│                     │               │                     │
│ + connect()         │               │ + connect()         │
│ + disconnect()      │               │ + disconnect()      │
│ + toggleAudio()     │               │ + toggleAudio()     │
└─────────────────────┘               └─────────────────────┘
```

**実装:**

```typescript
// features/video-call/services/IVideoService.ts

interface VideoConnectionConfig {
  sessionTopic: string;
  token: string;
  userName: string;
}

interface IVideoService {
  connect(config: VideoConnectionConfig): Promise<void>;
  disconnect(): Promise<void>;
  toggleAudio(): Promise<boolean>;
  toggleVideo(): Promise<boolean>;
  setVolume(participantId: string, level: VolumeLevel): Promise<void>;
  getParticipants(): Participant[];
  subscribeToEvents(observer: VideoSessionObserver): () => void;
}

// features/video-call/services/ZoomVideoAdapter.ts

class ZoomVideoAdapter implements IVideoService {
  private facade: ZoomVideoFacade;

  constructor(sessionSubject: VideoSessionSubject) {
    this.facade = new ZoomVideoFacade(sessionSubject);
  }

  async connect(config: VideoConnectionConfig): Promise<void> {
    await this.facade.joinSession({
      topic: config.sessionTopic,
      token: config.token,
      userName: config.userName,
      videoQuality: VideoQuality.Video_1080P
    });
  }

  async disconnect(): Promise<void> {
    await this.facade.leaveSession();
  }

  async toggleAudio(): Promise<boolean> {
    return this.facade.toggleMicrophone();
  }

  async toggleVideo(): Promise<boolean> {
    return this.facade.toggleCamera();
  }

  async setVolume(participantId: string, level: VolumeLevel): Promise<void> {
    await this.facade.setParticipantVolume(participantId, level.value);
  }

  getParticipants(): Participant[] {
    return this.facade.getParticipants();
  }

  subscribeToEvents(observer: VideoSessionObserver): () => void {
    return this.facade.subscribe(observer);
  }
}

// features/video-call/services/MockVideoAdapter.ts (テスト用)

class MockVideoAdapter implements IVideoService {
  private connected = false;
  private audioOn = false;
  private videoOn = false;
  private participants: Participant[] = [];

  async connect(_config: VideoConnectionConfig): Promise<void> {
    this.connected = true;
  }

  async disconnect(): Promise<void> {
    this.connected = false;
  }

  async toggleAudio(): Promise<boolean> {
    this.audioOn = !this.audioOn;
    return this.audioOn;
  }

  async toggleVideo(): Promise<boolean> {
    this.videoOn = !this.videoOn;
    return this.videoOn;
  }

  async setVolume(_participantId: string, _level: VolumeLevel): Promise<void> {
    // Mock implementation
  }

  getParticipants(): Participant[] {
    return this.participants;
  }

  // テスト用ヘルパー
  simulateParticipantJoin(participant: Participant): void {
    this.participants.push(participant);
  }

  subscribeToEvents(_observer: VideoSessionObserver): () => void {
    return () => {};
  }
}
```

---

#### 1.4.4 State Pattern（セッション状態管理）

セッションの状態遷移を明確に定義し、各状態での振る舞いをカプセル化します。

```
┌─────────────────────────────────────────────────────────────────┐
│                      State Diagram                               │
│                                                                  │
│     ┌─────────┐    connect()    ┌────────────┐                  │
│     │  Idle   │ ──────────────▶ │ Connecting │                  │
│     └─────────┘                 └────────────┘                  │
│          ▲                            │                          │
│          │                            │ success                  │
│          │ disconnect()               ▼                          │
│     ┌────┴──────┐              ┌────────────┐                   │
│     │Disconnected│◀──────────── │ Connected  │                   │
│     └───────────┘  disconnect() └────────────┘                  │
│          ▲                            │                          │
│          │              error         │ error                    │
│          └────────────────────────────┘                          │
└─────────────────────────────────────────────────────────────────┘
```

**実装:**

```typescript
// features/video-call/states/SessionState.ts

interface SessionContext {
  videoService: IVideoService;
  config: VideoConnectionConfig;
  onStateChange: (state: SessionState) => void;
  onError: (error: Error) => void;
}

abstract class SessionState {
  constructor(protected context: SessionContext) {}

  abstract get status(): SessionStatus;

  // 各状態で許可される操作（デフォルトは何もしない）
  async connect(): Promise<void> {
    console.warn(`Cannot connect in ${this.status} state`);
  }

  async disconnect(): Promise<void> {
    console.warn(`Cannot disconnect in ${this.status} state`);
  }

  async toggleAudio(): Promise<boolean> {
    console.warn(`Cannot toggle audio in ${this.status} state`);
    return false;
  }

  async toggleVideo(): Promise<boolean> {
    console.warn(`Cannot toggle video in ${this.status} state`);
    return false;
  }

  protected transitionTo(state: SessionState): void {
    this.context.onStateChange(state);
  }
}

// 各状態の実装

class IdleState extends SessionState {
  get status(): SessionStatus {
    return 'idle';
  }

  async connect(): Promise<void> {
    this.transitionTo(new ConnectingState(this.context));
  }
}

class ConnectingState extends SessionState {
  get status(): SessionStatus {
    return 'connecting';
  }

  constructor(context: SessionContext) {
    super(context);
    this.performConnection();
  }

  private async performConnection(): Promise<void> {
    try {
      await this.context.videoService.connect(this.context.config);
      this.transitionTo(new ConnectedState(this.context));
    } catch (error) {
      this.context.onError(error as Error);
      this.transitionTo(new DisconnectedState(this.context));
    }
  }
}

class ConnectedState extends SessionState {
  get status(): SessionStatus {
    return 'connected';
  }

  async disconnect(): Promise<void> {
    try {
      await this.context.videoService.disconnect();
      this.transitionTo(new DisconnectedState(this.context));
    } catch (error) {
      this.context.onError(error as Error);
      this.transitionTo(new DisconnectedState(this.context));
    }
  }

  async toggleAudio(): Promise<boolean> {
    return this.context.videoService.toggleAudio();
  }

  async toggleVideo(): Promise<boolean> {
    return this.context.videoService.toggleVideo();
  }
}

class DisconnectedState extends SessionState {
  get status(): SessionStatus {
    return 'disconnected';
  }

  async connect(): Promise<void> {
    this.transitionTo(new ConnectingState(this.context));
  }
}

// 状態マシンのコントローラー

class SessionStateMachine {
  private currentState: SessionState;

  constructor(
    private videoService: IVideoService,
    private config: VideoConnectionConfig
  ) {
    const context: SessionContext = {
      videoService,
      config,
      onStateChange: (state) => { this.currentState = state; },
      onError: (error) => { console.error('Session error:', error); }
    };
    this.currentState = new IdleState(context);
  }

  get status(): SessionStatus {
    return this.currentState.status;
  }

  connect(): Promise<void> {
    return this.currentState.connect();
  }

  disconnect(): Promise<void> {
    return this.currentState.disconnect();
  }

  toggleAudio(): Promise<boolean> {
    return this.currentState.toggleAudio();
  }

  toggleVideo(): Promise<boolean> {
    return this.currentState.toggleVideo();
  }
}
```

**React Hooksとの統合:**

```typescript
// features/video-call/hooks/useSessionState.ts

export const useSessionState = (videoService: IVideoService, config: VideoConnectionConfig) => {
  const [status, setStatus] = useState<SessionStatus>('idle');
  const [error, setError] = useState<Error | null>(null);

  const stateMachineRef = useRef<SessionStateMachine>();

  useEffect(() => {
    const context: SessionContext = {
      videoService,
      config,
      onStateChange: (state) => setStatus(state.status),
      onError: setError
    };
    stateMachineRef.current = new SessionStateMachine(videoService, config);
  }, [videoService, config]);

  const connect = useCallback(() => {
    return stateMachineRef.current?.connect();
  }, []);

  const disconnect = useCallback(() => {
    return stateMachineRef.current?.disconnect();
  }, []);

  const toggleAudio = useCallback(() => {
    return stateMachineRef.current?.toggleAudio();
  }, []);

  const toggleVideo = useCallback(() => {
    return stateMachineRef.current?.toggleVideo();
  }, []);

  return {
    status,
    error,
    connect,
    disconnect,
    toggleAudio,
    toggleVideo,
    isConnected: status === 'connected',
    isConnecting: status === 'connecting'
  };
};
```

---

#### 1.4.5 パターン適用の全体像

```
┌─────────────────────────────────────────────────────────────────┐
│                     Presentation Layer                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ VideoCallPage                                            │   │
│  │   └── useSessionState (State Pattern)                    │   │
│  │         └── SessionStateMachine                          │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Application Layer                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ VideoSessionSubject (Observer Pattern)                   │   │
│  │   └── observers: [VideoGrid, VolumeManager, ...]         │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Domain Layer                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ IVideoService (Adapter Pattern - Interface)              │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Infrastructure Layer                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ ZoomVideoAdapter (Adapter Pattern - Implementation)      │   │
│  │   └── ZoomVideoFacade (Facade Pattern)                   │   │
│  │         └── ZoomVideo SDK                                │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

| パターン | 責務 | 主なファイル |
|---------|------|-------------|
| Observer | イベント通知の疎結合化 | `features/video-call/observers/` |
| Facade | SDK複雑性の隠蔽 | `features/video-call/facade/ZoomVideoFacade.ts` |
| Adapter | SDK依存の分離 | `features/video-call/services/IVideoService.ts`, `ZoomVideoAdapter.ts` |
| State | 状態遷移の明確化 | `features/video-call/states/` |

---

## 2. ディレクトリ構成

### 2.1 フロントエンド (front/) - Feature-Based Architecture

機能（Feature）ごとにコードを分割し、各機能が独立して開発・テスト可能な構造を採用します。

```
front/
├── src/
│   ├── app/                           # アプリケーション設定
│   │   ├── App.tsx                    # ルートコンポーネント
│   │   ├── routes.tsx                 # ルーティング設定
│   │   └── providers/                 # グローバルProvider
│   │       ├── index.tsx
│   │       └── AppProviders.tsx
│   │
│   ├── features/                      # ★ 機能モジュール（メイン）
│   │   │
│   │   ├── auth/                      # 認証機能
│   │   │   ├── components/
│   │   │   │   ├── LoginForm/
│   │   │   │   │   ├── LoginForm.tsx
│   │   │   │   │   ├── LoginForm.test.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   └── index.ts
│   │   │   ├── hooks/
│   │   │   │   ├── useAuth.ts
│   │   │   │   └── index.ts
│   │   │   ├── api/
│   │   │   │   └── authApi.ts
│   │   │   ├── context/
│   │   │   │   └── AuthContext.tsx
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts               # Public API
│   │   │
│   │   ├── video-call/                # ビデオ通話機能
│   │   │   ├── components/
│   │   │   │   ├── MainVideoDisplay/
│   │   │   │   │   ├── MainVideoDisplay.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   ├── SubVideoDisplay/
│   │   │   │   │   ├── SubVideoDisplay.tsx
│   │   │   │   │   ├── VideoGrid.tsx
│   │   │   │   │   ├── VideoThumbnail.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   ├── SelfVideoDisplay/
│   │   │   │   │   ├── SelfVideoDisplay.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   ├── VideoControls/
│   │   │   │   │   ├── VideoControls.tsx
│   │   │   │   │   ├── MicrophoneButton.tsx
│   │   │   │   │   ├── CameraButton.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   ├── VerticalLayout/
│   │   │   │   │   ├── VerticalLayout.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   └── index.ts
│   │   │   ├── hooks/
│   │   │   │   ├── useSessionState.ts      # State Pattern統合
│   │   │   │   ├── useKeyboardShortcut.ts
│   │   │   │   ├── useVolumeControl.ts
│   │   │   │   └── index.ts
│   │   │   ├── services/                   # Adapter Pattern
│   │   │   │   ├── IVideoService.ts        # インターフェース
│   │   │   │   ├── ZoomVideoAdapter.ts     # 本番実装
│   │   │   │   ├── MockVideoAdapter.ts     # テスト用
│   │   │   │   └── index.ts
│   │   │   ├── facade/                     # Facade Pattern
│   │   │   │   ├── ZoomVideoFacade.ts
│   │   │   │   └── index.ts
│   │   │   ├── states/                     # State Pattern
│   │   │   │   ├── SessionState.ts
│   │   │   │   ├── IdleState.ts
│   │   │   │   ├── ConnectingState.ts
│   │   │   │   ├── ConnectedState.ts
│   │   │   │   ├── DisconnectedState.ts
│   │   │   │   └── index.ts
│   │   │   ├── observers/                  # Observer Pattern
│   │   │   │   ├── VideoSessionObserver.ts
│   │   │   │   ├── VideoSessionSubject.ts
│   │   │   │   └── index.ts
│   │   │   ├── context/
│   │   │   │   └── VideoContext.tsx
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts                    # Public API
│   │   │
│   │   ├── operating-hours/           # 稼働時間管理機能
│   │   │   ├── components/
│   │   │   │   ├── OperatingHoursWarning/
│   │   │   │   │   ├── OperatingHoursWarning.tsx
│   │   │   │   │   └── index.ts
│   │   │   │   └── index.ts
│   │   │   ├── hooks/
│   │   │   │   ├── useOperatingHoursMonitor.ts
│   │   │   │   └── index.ts
│   │   │   ├── api/
│   │   │   │   └── scheduleApi.ts
│   │   │   ├── observers/
│   │   │   │   ├── OperatingHoursObserver.ts
│   │   │   │   ├── OperatingHoursSubject.ts
│   │   │   │   └── index.ts
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   │
│   │   └── sites/                     # 拠点管理機能
│   │       ├── api/
│   │       │   └── siteApi.ts
│   │       ├── hooks/
│   │       │   └── useSites.ts
│   │       ├── types/
│   │       │   └── index.ts
│   │       └── index.ts
│   │
│   ├── entities/                      # 共有ドメインエンティティ
│   │   ├── user/
│   │   │   ├── User.ts
│   │   │   └── index.ts
│   │   ├── company/
│   │   │   ├── Company.ts
│   │   │   └── index.ts
│   │   ├── site/
│   │   │   ├── Site.ts
│   │   │   └── index.ts
│   │   ├── participant/
│   │   │   ├── Participant.ts
│   │   │   └── index.ts
│   │   └── index.ts
│   │
│   ├── shared/                        # 共有リソース
│   │   ├── components/                # 汎用UIコンポーネント
│   │   │   ├── Button/
│   │   │   │   ├── Button.tsx
│   │   │   │   └── index.ts
│   │   │   ├── Icon/
│   │   │   │   ├── Icon.tsx
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   ├── hooks/                     # 汎用フック
│   │   │   ├── useFullScreen.ts
│   │   │   └── index.ts
│   │   ├── lib/                       # ユーティリティ
│   │   │   ├── apiClient.ts
│   │   │   └── index.ts
│   │   ├── constants/
│   │   │   └── index.ts
│   │   └── types/
│   │       └── index.ts
│   │
│   ├── pages/                         # ページコンポーネント
│   │   ├── LoginPage/
│   │   │   ├── LoginPage.tsx
│   │   │   └── index.ts
│   │   ├── VideoCallPage/
│   │   │   ├── VideoCallPage.tsx
│   │   │   └── index.ts
│   │   ├── SessionEndedPage/
│   │   │   ├── SessionEndedPage.tsx
│   │   │   └── index.ts
│   │   └── index.ts
│   │
│   └── main.tsx                       # エントリポイント
│
├── tests/
│   ├── setup.ts
│   ├── mocks/
│   │   └── handlers.ts
│   └── e2e/
│       └── video-call.spec.ts
│
├── public/
├── index.html
├── vite.config.ts
├── tsconfig.json
└── package.json
```

#### Feature モジュールのルール

```typescript
// features/video-call/index.ts（Public API）
// 外部に公開するものだけをexport

// Components
export { MainVideoDisplay } from './components/MainVideoDisplay';
export { SubVideoDisplay } from './components/SubVideoDisplay';
export { SelfVideoDisplay } from './components/SelfVideoDisplay';
export { VideoControls } from './components/VideoControls';
export { VerticalLayout } from './components/VerticalLayout';

// Hooks
export { useSessionState } from './hooks';
export { useKeyboardShortcut } from './hooks';

// Context
export { VideoContext, VideoProvider } from './context/VideoContext';

// Types
export type { Participant, SessionStatus } from './types';

// 内部実装（ZoomVideoFacade, States等）はexportしない
```

#### 依存関係のルール

```
┌─────────────────────────────────────────────────────────────┐
│  pages/         →  features を組み合わせてページを構成      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  features/      →  他のfeatureを直接参照しない              │
│                    （共有が必要なら shared/ か entities/）  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  shared/        →  features に依存しない                    │
│  entities/      →  どこからでも参照可能                     │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 バックエンド (server/) - Feature-Based Architecture

バックエンドも機能ごとにモジュール化し、Vertical Slice Architectureを採用します。

```
server/
├── src/
│   ├── app/                           # アプリケーション設定
│   │   ├── app.ts                     # Expressアプリ設定
│   │   ├── server.ts                  # サーバー起動
│   │   └── routes.ts                  # ルート集約
│   │
│   ├── features/                      # ★ 機能モジュール（メイン）
│   │   │
│   │   ├── auth/                      # 認証機能
│   │   │   ├── controller/
│   │   │   │   └── AuthController.ts
│   │   │   ├── routes/
│   │   │   │   └── authRoutes.ts
│   │   │   ├── usecases/
│   │   │   │   ├── LoginUseCase.ts
│   │   │   │   └── GenerateJwtUseCase.ts
│   │   │   ├── validators/
│   │   │   │   └── authValidator.ts
│   │   │   ├── dto/
│   │   │   │   └── AuthDto.ts
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts               # Public API
│   │   │
│   │   ├── session/                   # セッション管理機能
│   │   │   ├── controller/
│   │   │   │   └── SessionController.ts
│   │   │   ├── routes/
│   │   │   │   └── sessionRoutes.ts
│   │   │   ├── usecases/
│   │   │   │   ├── CreateSessionUseCase.ts
│   │   │   │   └── JoinSessionUseCase.ts
│   │   │   ├── services/
│   │   │   │   └── ZoomJwtService.ts
│   │   │   ├── validators/
│   │   │   │   └── sessionValidator.ts
│   │   │   ├── dto/
│   │   │   │   └── SessionDto.ts
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   │
│   │   ├── operating-hours/           # 稼働時間管理機能
│   │   │   ├── controller/
│   │   │   │   └── ScheduleController.ts
│   │   │   ├── routes/
│   │   │   │   └── scheduleRoutes.ts
│   │   │   ├── usecases/
│   │   │   │   ├── CheckOperatingHoursUseCase.ts
│   │   │   │   ├── GetScheduleUseCase.ts
│   │   │   │   └── UpdateScheduleUseCase.ts
│   │   │   ├── services/
│   │   │   │   └── OperatingHoursService.ts
│   │   │   ├── middleware/
│   │   │   │   └── operatingHoursMiddleware.ts
│   │   │   ├── dto/
│   │   │   │   └── ScheduleDto.ts
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   │
│   │   └── sites/                     # 拠点管理機能
│   │       ├── controller/
│   │       │   └── SiteController.ts
│   │       ├── routes/
│   │       │   └── siteRoutes.ts
│   │       ├── usecases/
│   │       │   └── GetSitesUseCase.ts
│   │       ├── dto/
│   │       │   └── SiteDto.ts
│   │       ├── types/
│   │       │   └── index.ts
│   │       └── index.ts
│   │
│   ├── entities/                      # 共有ドメインエンティティ
│   │   ├── user/
│   │   │   ├── User.ts
│   │   │   ├── UserId.ts
│   │   │   └── index.ts
│   │   ├── company/
│   │   │   ├── Company.ts
│   │   │   ├── CompanyId.ts
│   │   │   └── index.ts
│   │   ├── site/
│   │   │   ├── Site.ts
│   │   │   └── index.ts
│   │   ├── session/
│   │   │   ├── Session.ts
│   │   │   ├── SessionTopic.ts
│   │   │   └── index.ts
│   │   ├── schedule/
│   │   │   ├── OperatingSchedule.ts
│   │   │   ├── OperatingScheduleException.ts
│   │   │   ├── TimeRange.ts
│   │   │   └── index.ts
│   │   └── index.ts
│   │
│   ├── shared/                        # 共有リソース
│   │   ├── middleware/                # 共通ミドルウェア
│   │   │   ├── authMiddleware.ts
│   │   │   ├── errorMiddleware.ts
│   │   │   ├── validationMiddleware.ts
│   │   │   └── index.ts
│   │   ├── errors/                    # 共通エラー
│   │   │   ├── AppError.ts
│   │   │   ├── AuthError.ts
│   │   │   ├── NotFoundError.ts
│   │   │   └── index.ts
│   │   ├── lib/                       # ユーティリティ
│   │   │   ├── jwt.ts
│   │   │   ├── password.ts
│   │   │   └── index.ts
│   │   ├── constants/
│   │   │   └── index.ts
│   │   └── types/
│   │       └── index.ts
│   │
│   ├── infrastructure/                # インフラストラクチャ
│   │   ├── database/
│   │   │   ├── prisma/
│   │   │   │   ├── client.ts
│   │   │   │   └── schema.prisma
│   │   │   └── repositories/          # リポジトリ実装
│   │   │       ├── UserRepository.ts
│   │   │       ├── CompanyRepository.ts
│   │   │       ├── SiteRepository.ts
│   │   │       ├── SessionRepository.ts
│   │   │       ├── ScheduleRepository.ts
│   │   │       └── index.ts
│   │   └── external/                  # 外部サービス
│   │       └── zoom/
│   │           └── ZoomClient.ts
│   │
│   └── config/                        # 設定
│       ├── env.ts
│       ├── constants.ts
│       └── index.ts
│
├── tests/
│   ├── setup.ts
│   ├── features/                      # 機能ごとのテスト
│   │   ├── auth/
│   │   │   └── auth.test.ts
│   │   ├── session/
│   │   │   └── session.test.ts
│   │   └── operating-hours/
│   │       └── operating-hours.test.ts
│   └── integration/
│       └── api.test.ts
│
├── prisma/
│   ├── schema.prisma
│   └── migrations/
│
├── tsconfig.json
└── package.json
```

#### Feature モジュールのルール（バックエンド）

```typescript
// features/session/index.ts（Public API）
// 外部に公開するものだけをexport

// Routes（app.tsで使用）
export { sessionRoutes } from './routes/sessionRoutes';

// UseCases（他のfeatureから使用する場合）
export { JoinSessionUseCase } from './usecases/JoinSessionUseCase';

// Types
export type { SessionDto } from './dto/SessionDto';

// 内部実装（ZoomJwtService等）はexportしない
```

#### ルート集約

```typescript
// app/routes.ts
import { Router } from 'express';
import { authRoutes } from '@/features/auth';
import { sessionRoutes } from '@/features/session';
import { scheduleRoutes } from '@/features/operating-hours';
import { siteRoutes } from '@/features/sites';

const router = Router();

router.use('/auth', authRoutes);
router.use('/sessions', sessionRoutes);
router.use('/schedules', scheduleRoutes);
router.use('/sites', siteRoutes);

export { router };
```

#### 依存関係のルール（バックエンド）

```
┌─────────────────────────────────────────────────────────────┐
│  app/            →  features のルートを集約                  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  features/       →  他のfeatureを直接参照しない              │
│                     （共有が必要なら shared/ か entities/）  │
│                     infrastructure/ を使用可能               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  shared/         →  features に依存しない                    │
│  entities/       →  どこからでも参照可能                     │
│  infrastructure/ →  entities のみに依存                      │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 画面設計

### 3.1 画面レイアウト（縦画面・90度回転）

```
┌────────────────────────────────────────┐
│                                        │  ↑
│                                        │  │
│                                        │  │
│          メイン表示エリア               │  │
│           (上部 80%)                   │  │  画面高さ
│                                        │  │  (4K: 3840px)
│         選択された拠点の映像            │  │
│                                        │  │
│                            ┌────────┐  │  │
│                            │ 自分   │  │  │  セルフビュー
│                            │        │  │  │  (右下・小)
├────────────────────────────┴────────┴──┤  │
│  ┌────────┐  ┌────────┐  ┌────────┐   │  │
│  │ 拠点A  │  │ 拠点B  │  │ 拠点C  │   │  │  サブ表示
│  │        │  │        │  │        │   │  │  (下部 20%)
│  └────────┘  └────────┘  └────────┘   │  ↓
├────────────────────────────────────────┤
│  [🎤]  [📹]                            │  コントロール
└────────────────────────────────────────┘
         ← 画面幅 (4K: 2160px) →
```

### 3.2 2拠点接続時のレイアウト

```
┌────────────────────────────────────────┐
│                                        │
│                                        │
│                                        │
│                                        │
│          相手拠点の映像                 │
│           (100% フル表示)              │
│                                        │
│                                        │
│                            ┌────────┐  │
│                            │ 自分   │  │  セルフビュー
│                            │        │  │  (右下・小)
├────────────────────────────┴────────┴──┤
│  [🎤]  [📹]                            │
└────────────────────────────────────────┘
```

### 3.3 コンポーネント階層

```
VideoCallPage
├── VerticalLayout
│   ├── MainVideoDisplay
│   │   ├── VideoCanvas (メイン拠点映像)
│   │   └── SelfVideoDisplay (右下・小サイズ)
│   │       └── VideoElement (自分の映像)
│   ├── SubVideoDisplay (3拠点以上時のみ表示)
│   │   └── VideoGrid
│   │       └── VideoThumbnail[] (サブ拠点映像)
│   └── VideoControls
│       ├── MicrophoneButton
│       └── CameraButton
└── KeyboardShortcutHandler
```

### 3.4 セルフビュー仕様

| 項目 | 値 |
|------|-----|
| 位置 | メイン表示エリア右下 |
| サイズ | 画面幅の15%程度 |
| アスペクト比 | 16:9 |
| 表示条件 | カメラON時のみ表示 |
| z-index | メイン映像より上 |

---

## 4. 状態管理設計

### 4.1 AuthContext

```typescript
interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  company: Company | null;
  token: string | null;
  loading: boolean;
  error: string | null;
}

type AuthAction =
  | { type: 'LOGIN_START' }
  | { type: 'LOGIN_SUCCESS'; payload: { user: User; company: Company; token: string } }
  | { type: 'LOGIN_FAILURE'; payload: string }
  | { type: 'LOGOUT' };
```

### 4.2 VideoContext

```typescript
interface VideoState {
  sessionStatus: 'idle' | 'connecting' | 'connected' | 'disconnected';
  participants: Participant[];
  mainSiteId: string | null;
  localMedia: {
    isMicOn: boolean;
    isCameraOn: boolean;
  };
  volumeSettings: Record<string, number>;  // siteId -> volume (0-100)
  error: string | null;
}

type VideoAction =
  | { type: 'CONNECT_START' }
  | { type: 'CONNECT_SUCCESS'; payload: Participant[] }
  | { type: 'CONNECT_FAILURE'; payload: string }
  | { type: 'PARTICIPANT_JOIN'; payload: Participant }
  | { type: 'PARTICIPANT_LEAVE'; payload: string }
  | { type: 'SWITCH_MAIN_SITE'; payload: string }
  | { type: 'TOGGLE_MIC' }
  | { type: 'TOGGLE_CAMERA' }
  | { type: 'DISCONNECT' };
```

---

## 5. API設計

### 5.1 認証API

#### POST /api/auth/login
ユーザーログイン

**Request:**
```json
{
  "email": "user@example.com",
  "password": "password123"
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid",
      "name": "山田太郎",
      "email": "user@example.com",
      "siteId": "site-nagoya"
    },
    "company": {
      "id": "company-uuid",
      "name": "株式会社サンプル"
    },
    "accessToken": "eyJhbGciOiJIUzI1NiIs..."
  }
}
```

### 5.2 セッションAPI

#### POST /api/sessions/join
セッションに参加（Zoom JWT取得）

**Request:**
```json
{
  "siteId": "site-nagoya"
}
```

**Response (成功時):**
```json
{
  "success": true,
  "data": {
    "zoomJwt": "eyJhbGciOiJIUzI1NiIs...",
    "sessionTopic": "company-uuid-session",
    "userName": "名古屋",
    "sites": [
      { "id": "site-tokyo", "name": "東京", "isOnline": true },
      { "id": "site-osaka", "name": "大阪", "isOnline": true },
      { "id": "site-fukuoka", "name": "福岡", "isOnline": false }
    ],
    "operatingHours": {
      "endTime": "18:00",
      "remainingMinutes": 120,
      "warningThresholdMinutes": 5
    }
  }
}
```

**Response (稼働時間外エラー):**
```json
{
  "success": false,
  "error": {
    "code": "OUTSIDE_OPERATING_HOURS",
    "message": "現在は稼働時間外です",
    "details": {
      "currentTime": "19:30",
      "operatingHours": {
        "startTime": "09:00",
        "endTime": "18:00"
      },
      "nextOperatingDay": "2025-01-06",
      "nextStartTime": "09:00"
    }
  }
}
```

### 5.3 拠点API

#### GET /api/sites
会社の拠点一覧取得

**Response:**
```json
{
  "success": true,
  "data": {
    "sites": [
      { "id": "site-tokyo", "name": "東京", "displayOrder": 1 },
      { "id": "site-nagoya", "name": "名古屋", "displayOrder": 2 },
      { "id": "site-osaka", "name": "大阪", "displayOrder": 3 },
      { "id": "site-fukuoka", "name": "福岡", "displayOrder": 4 }
    ]
  }
}
```

### 5.4 稼働時間管理API

#### GET /api/schedules
稼働スケジュール一覧取得

**Response:**
```json
{
  "success": true,
  "data": {
    "schedules": [
      { "dayOfWeek": 0, "startTime": null, "endTime": null, "isEnabled": false },
      { "dayOfWeek": 1, "startTime": "09:00", "endTime": "18:00", "isEnabled": true },
      { "dayOfWeek": 2, "startTime": "09:00", "endTime": "18:00", "isEnabled": true },
      { "dayOfWeek": 3, "startTime": "09:00", "endTime": "18:00", "isEnabled": true },
      { "dayOfWeek": 4, "startTime": "09:00", "endTime": "18:00", "isEnabled": true },
      { "dayOfWeek": 5, "startTime": "09:00", "endTime": "18:00", "isEnabled": true },
      { "dayOfWeek": 6, "startTime": null, "endTime": null, "isEnabled": false }
    ],
    "exceptions": [
      { "date": "2025-01-01", "type": "holiday", "description": "元日" },
      { "date": "2025-03-15", "type": "custom", "startTime": "10:00", "endTime": "15:00", "description": "臨時稼働" }
    ],
    "timezone": "Asia/Tokyo"
  }
}
```

#### PUT /api/schedules
稼働スケジュール更新（管理者のみ）

**Request:**
```json
{
  "schedules": [
    { "dayOfWeek": 1, "startTime": "08:30", "endTime": "17:30", "isEnabled": true }
  ]
}
```

#### POST /api/schedules/exceptions
例外日の追加（管理者のみ）

**Request:**
```json
{
  "date": "2025-12-29",
  "type": "closed",
  "description": "年末休業"
}
```

#### GET /api/schedules/status
現在の稼働状態を取得

**Response:**
```json
{
  "success": true,
  "data": {
    "isOperating": true,
    "currentTime": "14:30",
    "todaySchedule": {
      "startTime": "09:00",
      "endTime": "18:00"
    },
    "remainingMinutes": 210,
    "warningThresholdMinutes": 5
  }
}
```

---

## 6. キーボードショートカット設計

| キー | 機能 |
|------|------|
| `1` | 1番目の拠点をメインに表示 |
| `2` | 2番目の拠点をメインに表示 |
| `3` | 3番目の拠点をメインに表示 |
| `4` | 4番目の拠点をメインに表示 |
| `M` | マイクのミュート切り替え |
| `V` | カメラのオン/オフ切り替え |
| `←` / `→` | メイン表示の前後切り替え |

---

## 7. 音量制御設計

### 7.1 音量レベル定数

```typescript
// config/constants.ts
export const VOLUME_LEVELS = {
  MAIN: 100,      // メイン拠点: 最大音量
  SUB: 30,        // サブ拠点: 30%音量
  MUTED: 0        // ミュート
} as const;
```

### 7.2 音量切り替えロジック

```typescript
// メイン拠点切り替え時の音量調整
const switchMainSite = (newMainSiteId: string) => {
  // 前のメイン拠点を低音量に
  if (currentMainSiteId) {
    zoomMediaStream.adjustUserVolume(currentMainSiteId, VOLUME_LEVELS.SUB);
  }

  // 新しいメイン拠点を高音量に
  zoomMediaStream.adjustUserVolume(newMainSiteId, VOLUME_LEVELS.MAIN);

  setMainSiteId(newMainSiteId);
};
```

---

## 8. 稼働時間管理設計

### 8.1 稼働時間チェックフロー

```
┌─────────────────────────────────────────────────────────────────┐
│                    セッション参加リクエスト                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│              operatingHoursMiddleware.ts                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 1. 会社IDからタイムゾーン取得                             │   │
│  │ 2. 現在日時を会社タイムゾーンで取得                        │   │
│  │ 3. 例外日（祝日・臨時休業）チェック                        │   │
│  │ 4. 通常スケジュールチェック                               │   │
│  │ 5. 稼働時間内 → next() / 時間外 → エラーレスポンス         │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
           ┌──────────────────┴──────────────────┐
           ▼                                     ▼
   ┌───────────────┐                    ┌───────────────┐
   │   稼働時間内   │                    │  稼働時間外   │
   │  セッション参加│                    │  エラー返却   │
   └───────────────┘                    └───────────────┘
```

### 8.2 稼働時間判定ロジック

```typescript
// application/services/OperatingHoursService.ts

interface OperatingStatus {
  isOperating: boolean;
  currentTime: string;
  todaySchedule: { startTime: string; endTime: string } | null;
  remainingMinutes: number | null;
  reason?: 'holiday' | 'closed' | 'outside_hours' | 'day_off';
}

class OperatingHoursService {
  async checkOperatingStatus(companyId: string): Promise<OperatingStatus> {
    const company = await this.companyRepository.findById(companyId);
    const now = this.getCurrentTimeInTimezone(company.timezone);
    const today = now.toISODate();
    const dayOfWeek = now.weekday % 7; // 0-6 (日曜=0)

    // 1. 例外日チェック（祝日・臨時休業・臨時稼働）
    const exception = await this.scheduleRepository.findException(companyId, today);
    if (exception) {
      return this.handleException(exception, now);
    }

    // 2. 通常スケジュールチェック
    const schedule = await this.scheduleRepository.findByDayOfWeek(companyId, dayOfWeek);
    if (!schedule?.isEnabled) {
      return { isOperating: false, reason: 'day_off', ... };
    }

    // 3. 時間範囲チェック
    return this.checkTimeRange(schedule, now);
  }
}
```

### 8.3 自動退出（キック）機能

```
┌─────────────────────────────────────────────────────────────────┐
│                     クライアント側                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              OperatingHoursMonitor                       │   │
│  │                                                          │   │
│  │  ┌──────────────────┐      ┌──────────────────────────┐ │   │
│  │  │ 残り時間カウント   │ ──▶ │ 5分前: 警告通知表示       │ │   │
│  │  │ (1分間隔でAPI確認) │      └──────────────────────────┘ │   │
│  │  └──────────────────┘                                    │   │
│  │           │                                              │   │
│  │           ▼                                              │   │
│  │  ┌──────────────────┐      ┌──────────────────────────┐ │   │
│  │  │ 残り0分到達       │ ──▶ │ 自動退出処理実行          │ │   │
│  │  └──────────────────┘      │ ・Zoomセッション離脱      │ │   │
│  │                            │ ・終了画面へ遷移          │ │   │
│  │                            └──────────────────────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 8.4 フロントエンド実装

```typescript
// presentation/hooks/useOperatingHoursMonitor.ts

const POLLING_INTERVAL_MS = 60000;  // 1分間隔
const WARNING_THRESHOLD_MINUTES = 5;

export const useOperatingHoursMonitor = () => {
  const [remainingMinutes, setRemainingMinutes] = useState<number | null>(null);
  const [showWarning, setShowWarning] = useState(false);
  const { disconnect } = useVideoContext();

  useEffect(() => {
    const checkStatus = async () => {
      const status = await operatingHoursApi.getStatus();

      if (!status.isOperating) {
        // 稼働時間外になった → 強制退出
        await disconnect();
        navigate('/session-ended', { reason: 'operating_hours_ended' });
        return;
      }

      setRemainingMinutes(status.remainingMinutes);

      // 警告表示
      if (status.remainingMinutes <= WARNING_THRESHOLD_MINUTES) {
        setShowWarning(true);
      }
    };

    const interval = setInterval(checkStatus, POLLING_INTERVAL_MS);
    checkStatus(); // 初回即時実行

    return () => clearInterval(interval);
  }, []);

  return { remainingMinutes, showWarning };
};
```

### 8.5 警告通知コンポーネント

```typescript
// presentation/components/OperatingHoursWarning.tsx

const OperatingHoursWarning: React.FC<{ remainingMinutes: number }> = ({
  remainingMinutes
}) => {
  if (remainingMinutes > WARNING_THRESHOLD_MINUTES) {
    return null;
  }

  return (
    <div className="operating-hours-warning">
      <span>稼働終了まで残り {remainingMinutes} 分です</span>
      <span>終了時刻になると自動的に通話が終了します</span>
    </div>
  );
};
```

### 8.6 定数定義

```typescript
// config/constants.ts

export const OPERATING_HOURS = {
  POLLING_INTERVAL_MS: 60000,         // 状態確認間隔（1分）
  WARNING_THRESHOLD_MINUTES: 5,        // 警告表示の閾値（終了5分前）
  GRACE_PERIOD_SECONDS: 30,           // 終了後の猶予時間（30秒）
} as const;

export const DAY_OF_WEEK = {
  SUNDAY: 0,
  MONDAY: 1,
  TUESDAY: 2,
  WEDNESDAY: 3,
  THURSDAY: 4,
  FRIDAY: 5,
  SATURDAY: 6,
} as const;
```

---

## 9. セキュリティ設計

### 9.1 マルチテナント分離

```
セッションtopic命名規則: {companyId}-video-session

例:
- 会社A: company-a-uuid-video-session
- 会社B: company-b-uuid-video-session

→ 異なる会社は異なるtopicを使用するため、相互アクセス不可
```

### 9.2 JWT認証フロー

```
1. ユーザー: ログイン情報送信
   ↓
2. サーバー: ユーザー認証 → アクセストークン発行
   ↓
3. ユーザー: セッション参加リクエスト (アクセストークン付き)
   ↓
4. サーバー: 会社ID検証 → Zoom SDK JWT生成
   ↓
5. ユーザー: Zoom SDK JWT でビデオセッション接続
```

### 9.3 セキュリティ対策

| 対策 | 実装 |
|------|------|
| HTTPS強制 | Helmet middleware |
| CORS制限 | 許可オリジンのみ |
| JWT有効期限 | 2時間（Zoom SDK JWT） |
| レート制限 | express-rate-limit |
| 入力検証 | Zod / class-validator |

---

## 10. エラーハンドリング設計

### 10.1 カスタム例外クラス

```typescript
// domain/errors/AppError.ts
abstract class AppError extends Error {
  abstract readonly statusCode: number;
  abstract readonly isOperational: boolean;
}

class AuthenticationError extends AppError {
  readonly statusCode = 401;
  readonly isOperational = true;
}

class AuthorizationError extends AppError {
  readonly statusCode = 403;
  readonly isOperational = true;
}

class NotFoundError extends AppError {
  readonly statusCode = 404;
  readonly isOperational = true;
}

class VideoConnectionError extends AppError {
  readonly statusCode = 500;
  readonly isOperational = true;
}
```

### 10.2 フロントエンドエラーハンドリング

```typescript
// Zoom SDK接続エラー時のリトライ戦略
const MAX_RETRY_COUNT = 3;
const RETRY_DELAY_MS = 2000;

const connectWithRetry = async (retryCount = 0): Promise<void> => {
  try {
    await zoomClient.join(topic, token, userName);
  } catch (error) {
    if (retryCount < MAX_RETRY_COUNT) {
      await delay(RETRY_DELAY_MS);
      return connectWithRetry(retryCount + 1);
    }
    throw new VideoConnectionError('接続に失敗しました');
  }
};
```

---

## 11. テスト戦略

### 11.1 テストピラミッド

```
        /\
       /  \       E2E テスト (少数)
      /    \      - 主要ユーザーフロー
     /──────\
    /        \    統合テスト (中程度)
   /          \   - API エンドポイント
  /────────────\  - コンポーネント連携
 /              \
/                \ ユニットテスト (多数)
──────────────────  - ドメインロジック
                    - ユースケース
                    - ユーティリティ関数
```

### 11.2 TDDサイクル

```
1. Red: 失敗するテストを書く
   ↓
2. Green: テストが通る最小限のコードを書く
   ↓
3. Refactor: コードを改善（テストは通ったまま）
   ↓
1. に戻る
```

### 11.3 テスト対象

| レイヤー | テスト対象 | ツール |
|---------|-----------|--------|
| Domain | エンティティ、値オブジェクト | Vitest |
| Application | ユースケース | Vitest + Mock |
| Presentation | コンポーネント | Testing Library |
| Infrastructure | リポジトリ | Vitest + Prisma Mock |
| E2E | ユーザーフロー | Playwright |

---

## 12. 今後の拡張性

### 12.1 機能拡張ポイント

| 機能 | 拡張方法 |
|------|---------|
| 4K対応 | VideoQuality.Video_4K 使用 |
| 拠点追加 | DB登録のみで対応可能 |
| 録画機能 | Zoom SDK RecordingClient 使用 |
| 画面共有 | Zoom SDK Share機能 使用 |
| チャット | Zoom SDK ChatClient 使用 |

### 12.2 スケーリング

- フロントエンド: CDN配信
- バックエンド: 水平スケーリング対応（ステートレス設計）
- データベース: Supabaseのスケーリング機能活用
