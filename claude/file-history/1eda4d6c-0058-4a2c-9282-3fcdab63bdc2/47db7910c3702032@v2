import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, act, waitFor } from '@testing-library/react';
import { useSessionState } from './useSessionState';
import type { IVideoService } from '../services';
import type { VideoConnectionConfig } from '../types';

describe('useSessionState', () => {
  let mockVideoService: IVideoService;
  const mockConfig: VideoConnectionConfig = {
    sessionTopic: 'test-topic',
    token: 'test-token',
    userName: 'テスト拠点',
  };

  beforeEach(() => {
    mockVideoService = {
      connect: vi.fn().mockResolvedValue(undefined),
      disconnect: vi.fn().mockResolvedValue(undefined),
      toggleAudio: vi.fn().mockResolvedValue(true),
      toggleVideo: vi.fn().mockResolvedValue(true),
      setVolume: vi.fn().mockResolvedValue(undefined),
      getParticipants: vi.fn().mockReturnValue([]),
      subscribeToEvents: vi.fn().mockReturnValue(() => {}),
      isConnected: vi.fn().mockReturnValue(false),
      isAudioOn: vi.fn().mockReturnValue(false),
      isVideoOn: vi.fn().mockReturnValue(false),
      attachVideo: vi.fn().mockResolvedValue(undefined),
      detachVideo: vi.fn().mockResolvedValue(undefined),
      attachSelfVideo: vi.fn().mockResolvedValue(undefined),
      detachSelfVideo: vi.fn().mockResolvedValue(undefined),
    };
  });

  it('初期状態がidleであること', () => {
    const { result } = renderHook(() =>
      useSessionState(mockVideoService, mockConfig)
    );

    expect(result.current.status).toBe('idle');
    expect(result.current.isIdle).toBe(true);
    expect(result.current.isConnected).toBe(false);
    expect(result.current.isConnecting).toBe(false);
    expect(result.current.isDisconnected).toBe(false);
    expect(result.current.error).toBeNull();
  });

  it('connectを呼ぶと接続処理が開始されること', async () => {
    const { result } = renderHook(() =>
      useSessionState(mockVideoService, mockConfig)
    );

    await act(async () => {
      await result.current.connect();
    });

    await waitFor(() => {
      expect(mockVideoService.connect).toHaveBeenCalledWith(mockConfig);
    });
  });

  it('接続成功後にconnected状態になること', async () => {
    const { result } = renderHook(() =>
      useSessionState(mockVideoService, mockConfig)
    );

    await act(async () => {
      await result.current.connect();
    });

    await waitFor(() => {
      expect(result.current.status).toBe('connected');
      expect(result.current.isConnected).toBe(true);
    });
  });

  it('接続エラー時にerrorが設定されること', async () => {
    const testError = new Error('接続エラー');
    mockVideoService.connect = vi.fn().mockRejectedValue(testError);

    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

    const { result } = renderHook(() =>
      useSessionState(mockVideoService, mockConfig)
    );

    await act(async () => {
      await result.current.connect();
    });

    await waitFor(() => {
      expect(result.current.error).not.toBeNull();
    });

    consoleSpy.mockRestore();
  });

  it('disconnectを呼ぶと切断処理が実行されること', async () => {
    const { result } = renderHook(() =>
      useSessionState(mockVideoService, mockConfig)
    );

    // 先に接続
    await act(async () => {
      await result.current.connect();
    });

    await waitFor(() => {
      expect(result.current.isConnected).toBe(true);
    });

    // 切断
    await act(async () => {
      await result.current.disconnect();
    });

    await waitFor(() => {
      expect(mockVideoService.disconnect).toHaveBeenCalled();
      expect(result.current.status).toBe('disconnected');
      expect(result.current.isDisconnected).toBe(true);
    });
  });

  it('toggleAudioが正しく動作すること', async () => {
    const { result } = renderHook(() =>
      useSessionState(mockVideoService, mockConfig)
    );

    // 接続
    await act(async () => {
      await result.current.connect();
    });

    await waitFor(() => {
      expect(result.current.isConnected).toBe(true);
    });

    let audioResult: boolean = false;
    await act(async () => {
      audioResult = await result.current.toggleAudio();
    });

    expect(audioResult).toBe(true);
    expect(mockVideoService.toggleAudio).toHaveBeenCalled();
  });

  it('toggleVideoが正しく動作すること', async () => {
    const { result } = renderHook(() =>
      useSessionState(mockVideoService, mockConfig)
    );

    // 接続
    await act(async () => {
      await result.current.connect();
    });

    await waitFor(() => {
      expect(result.current.isConnected).toBe(true);
    });

    let videoResult: boolean = false;
    await act(async () => {
      videoResult = await result.current.toggleVideo();
    });

    expect(videoResult).toBe(true);
    expect(mockVideoService.toggleVideo).toHaveBeenCalled();
  });

  it('clearErrorでエラーをクリアできること', async () => {
    const testError = new Error('テストエラー');
    mockVideoService.connect = vi.fn().mockRejectedValue(testError);

    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

    const { result } = renderHook(() =>
      useSessionState(mockVideoService, mockConfig)
    );

    await act(async () => {
      await result.current.connect();
    });

    await waitFor(() => {
      expect(result.current.error).not.toBeNull();
    });

    act(() => {
      result.current.clearError();
    });

    expect(result.current.error).toBeNull();

    consoleSpy.mockRestore();
  });

  it('未接続状態でtoggleAudioを呼んでもfalseを返すこと', async () => {
    const { result } = renderHook(() =>
      useSessionState(mockVideoService, mockConfig)
    );

    await act(async () => {
      await result.current.toggleAudio();
    });

    // idle状態ではtoggleAudioは何もしない（Stateによってはfalseやエラーになる）
    expect(mockVideoService.toggleAudio).not.toHaveBeenCalled();
  });

  it('未接続状態でtoggleVideoを呼んでもfalseを返すこと', async () => {
    const { result } = renderHook(() =>
      useSessionState(mockVideoService, mockConfig)
    );

    await act(async () => {
      await result.current.toggleVideo();
    });

    // idle状態ではtoggleVideoは何もしない
    expect(mockVideoService.toggleVideo).not.toHaveBeenCalled();
  });
});
