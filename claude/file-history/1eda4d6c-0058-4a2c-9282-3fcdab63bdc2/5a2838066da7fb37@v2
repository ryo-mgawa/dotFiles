import type { Participant } from '@/entities';
import type { IVideoService, VideoAttachOptions } from './IVideoService';
import type { VideoConnectionConfig, VolumeLevel } from '../types';
import type { VideoSessionObserver } from '../observers';
import { VideoSessionSubject } from '../observers';

/**
 * テスト用モックビデオアダプター
 * Zoom SDKを使用せずにビデオ機能をシミュレートする
 */
export class MockVideoAdapter implements IVideoService {
  private connected = false;
  private audioOn = false;
  private videoOn = false;
  private participants: Participant[] = [];
  private subject: VideoSessionSubject = new VideoSessionSubject();

  async connect(_config: VideoConnectionConfig): Promise<void> {
    // 接続をシミュレート
    await this.delay(500);
    this.connected = true;
    this.audioOn = true;
    this.videoOn = true;
  }

  async disconnect(): Promise<void> {
    await this.delay(100);
    this.connected = false;
    this.audioOn = false;
    this.videoOn = false;
    this.participants = [];
    this.subject.clear();
  }

  async toggleAudio(): Promise<boolean> {
    this.audioOn = !this.audioOn;
    return this.audioOn;
  }

  async toggleVideo(): Promise<boolean> {
    this.videoOn = !this.videoOn;
    return this.videoOn;
  }

  async setVolume(_participantId: string, _level: VolumeLevel): Promise<void> {
    // モック実装では何もしない
  }

  getParticipants(): Participant[] {
    return [...this.participants];
  }

  subscribeToEvents(observer: VideoSessionObserver): () => void {
    return this.subject.subscribe(observer);
  }

  isConnected(): boolean {
    return this.connected;
  }

  isAudioOn(): boolean {
    return this.audioOn;
  }

  isVideoOn(): boolean {
    return this.videoOn;
  }

  async attachVideo(_options: VideoAttachOptions): Promise<void> {
    // モック実装: コンテナにモックビデオを追加
    _options.container.innerHTML = '<div style="width:100%;height:100%;background:#333;display:flex;align-items:center;justify-content:center;color:white;">Video Mock</div>';
  }

  async detachVideo(_participantId: string, container: HTMLElement): Promise<void> {
    // モック実装: コンテナをクリア
    container.innerHTML = '';
  }

  async attachSelfVideo(container: HTMLElement): Promise<void> {
    // モック実装: セルフビュー用
    container.innerHTML = '<div style="width:100%;height:100%;background:#1a1a1a;display:flex;align-items:center;justify-content:center;color:#888;">Self View</div>';
  }

  async detachSelfVideo(container: HTMLElement): Promise<void> {
    // モック実装: セルフビュー要素をクリア
    container.innerHTML = '';
  }

  // テスト用ヘルパーメソッド

  /**
   * 参加者の参加をシミュレート
   */
  simulateParticipantJoin(participant: Participant): void {
    this.participants.push(participant);
    this.subject.notify({
      type: 'PARTICIPANT_JOIN',
      participant,
      timestamp: new Date(),
    });
  }

  /**
   * 参加者の離脱をシミュレート
   */
  simulateParticipantLeave(participantId: string): void {
    const participant = this.participants.find(p => p.id === participantId);
    if (participant) {
      this.participants = this.participants.filter(p => p.id !== participantId);
      this.subject.notify({
        type: 'PARTICIPANT_LEAVE',
        participant,
        timestamp: new Date(),
      });
    }
  }

  /**
   * 参加者の状態更新をシミュレート
   */
  simulateParticipantUpdate(participant: Participant): void {
    const index = this.participants.findIndex(p => p.id === participant.id);
    if (index !== -1) {
      this.participants[index] = participant;
      this.subject.notify({
        type: 'PARTICIPANT_UPDATE',
        participant,
        timestamp: new Date(),
      });
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
