import type { OperatingSchedule, OperatingScheduleException, ExceptionType } from '@/entities/index.js';
import type { IScheduleRepository } from './IScheduleRepository.js';
import { prisma } from '../prisma/client.js';

export class ScheduleRepository implements IScheduleRepository {
  async findByCompanyId(companyId: string): Promise<OperatingSchedule[]> {
    const schedules = await prisma.operatingSchedule.findMany({
      where: { companyId },
      orderBy: { dayOfWeek: 'asc' },
    });

    return schedules.map((s) => this.mapToEntity(s));
  }

  async findByCompanyIdAndDayOfWeek(
    companyId: string,
    dayOfWeek: number
  ): Promise<OperatingSchedule | null> {
    const schedule = await prisma.operatingSchedule.findUnique({
      where: {
        companyId_dayOfWeek: { companyId, dayOfWeek },
      },
    });

    if (!schedule) return null;

    return this.mapToEntity(schedule);
  }

  async findExceptionByDate(
    companyId: string,
    date: Date
  ): Promise<OperatingScheduleException | null> {
    const startOfDay = new Date(date);
    startOfDay.setHours(0, 0, 0, 0);

    const endOfDay = new Date(date);
    endOfDay.setHours(23, 59, 59, 999);

    const exception = await prisma.operatingScheduleException.findFirst({
      where: {
        companyId,
        exceptionDate: {
          gte: startOfDay,
          lte: endOfDay,
        },
      },
    });

    if (!exception) return null;

    return this.mapExceptionToEntity(exception);
  }

  async findExceptionsByCompanyId(companyId: string): Promise<OperatingScheduleException[]> {
    const exceptions = await prisma.operatingScheduleException.findMany({
      where: { companyId },
      orderBy: { exceptionDate: 'asc' },
    });

    return exceptions.map((e) => this.mapExceptionToEntity(e));
  }

  async upsertSchedule(
    companyId: string,
    dayOfWeek: number,
    data: {
      startTime: Date | null;
      endTime: Date | null;
      isEnabled: boolean;
    }
  ): Promise<OperatingSchedule> {
    const schedule = await prisma.operatingSchedule.upsert({
      where: {
        companyId_dayOfWeek: { companyId, dayOfWeek },
      },
      update: data,
      create: {
        companyId,
        dayOfWeek,
        ...data,
      },
    });

    return this.mapToEntity(schedule);
  }

  async createException(data: {
    companyId: string;
    exceptionDate: Date;
    exceptionType: string;
    startTime?: Date | null;
    endTime?: Date | null;
    description?: string | null;
  }): Promise<OperatingScheduleException> {
    const exception = await prisma.operatingScheduleException.create({
      data: {
        companyId: data.companyId,
        exceptionDate: data.exceptionDate,
        exceptionType: data.exceptionType,
        startTime: data.startTime ?? null,
        endTime: data.endTime ?? null,
        description: data.description ?? null,
      },
    });

    return this.mapExceptionToEntity(exception);
  }

  async deleteException(id: string): Promise<void> {
    await prisma.operatingScheduleException.delete({
      where: { id },
    });
  }

  private mapToEntity(schedule: {
    id: string;
    companyId: string;
    dayOfWeek: number;
    startTime: Date | null;
    endTime: Date | null;
    isEnabled: boolean;
    createdAt: Date;
    updatedAt: Date;
  }): OperatingSchedule {
    return {
      id: schedule.id,
      companyId: schedule.companyId,
      dayOfWeek: schedule.dayOfWeek,
      startTime: schedule.startTime,
      endTime: schedule.endTime,
      isEnabled: schedule.isEnabled,
      createdAt: schedule.createdAt,
      updatedAt: schedule.updatedAt,
    };
  }

  private mapExceptionToEntity(exception: {
    id: string;
    companyId: string;
    exceptionDate: Date;
    exceptionType: string;
    startTime: Date | null;
    endTime: Date | null;
    description: string | null;
    createdAt: Date;
    updatedAt: Date;
  }): OperatingScheduleException {
    return {
      id: exception.id,
      companyId: exception.companyId,
      exceptionDate: exception.exceptionDate,
      exceptionType: exception.exceptionType as ExceptionType,
      startTime: exception.startTime,
      endTime: exception.endTime,
      description: exception.description,
      createdAt: exception.createdAt,
      updatedAt: exception.updatedAt,
    };
  }
}
