import { Logger } from '@app/logger';
import { ProviderIdentity } from '@app/rdb';
import { Inject, Injectable } from '@nestjs/common';
import { Knex } from 'knex';
import { ShipmentSaveException } from '../../exception/shipmentSaveException';
import { Shipment } from '../model/shipment';
import { SaveShipment } from './types/saveShipment';

@Injectable()
export class ShipmentDAO {
  constructor(@Inject(ProviderIdentity) private rdb: Knex) {}

  public async saveShipments(shipments: SaveShipment[]): Promise<void> {
    if (shipments.length === 0) {
      return;
    }

    const records = shipments.map((s) => ({
      id: s.id,
      organization_id: s.organizationId,
      slip_id: s.slipId,
      consignor: JSON.stringify(s.consignor),
      consignee: JSON.stringify(s.consignee),
      origin_spot_id: s.originSpotId,
      destination_spot_id: s.destinationSpotId,
      meta: s.meta ? JSON.stringify(s.meta) : null,
    }));

    return this.rdb
      .transaction(async (trx) => {
        await trx('shipment').insert(records);
      })
      .catch((error: Error) => {
        Logger.error(error);
        throw new ShipmentSaveException('シップメント情報の保存に失敗しました。');
      });
  }

  public async getShipments(
    organizationId: string,
    limit: number,
    offset: number
  ): Promise<Shipment[]> {
    const records = await this.rdb
      .from('shipment')
      .where('organization_id', organizationId)
      .orderBy('created_at', 'desc')
      .limit(limit)
      .offset(offset)
      .select(
        'id',
        'organization_id',
        'slip_id',
        'consignor',
        'consignee',
        'origin_spot_id',
        'destination_spot_id',
        'meta'
      );

    return records.map((record) => ({
      id: record.id,
      organizationId: record.organization_id,
      slipId: record.slip_id,
      consignor: record.consignor,
      consignee: record.consignee,
      originSpotId: record.origin_spot_id,
      destinationSpotId: record.destination_spot_id,
      meta: record.meta,
    }));
  }
}
