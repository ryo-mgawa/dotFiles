import { resolve } from 'path';
import { ProviderIdentity, RDBModule } from '@app/rdb';
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { Knex } from 'knex';
import { v7 as uuidv7 } from 'uuid';
import { ShipmentDAO } from '../shipmentDAO';
import { SHIPMENT_EVENT_TYPE } from '@app/rdb/db/models/shipmentEvent/type';
import { SHIPMENT_STATUS } from '@app/rdb/db/models/shipmentStatus/status';

jest.mock('@app/requestContext/requestContext', () => {
  return {
    RequestContext: class DummyRequestContext {
      public static get() {
        return {
          user: {
            organizationId: 'test-org-1',
            userId: 'test-user-1',
            role: 'manager',
          },
        };
      }
      public static start(_, next) {
        next();
      }
    },
  };
});

describe('ShipmentDAO', () => {
  let shipmentDAO: ShipmentDAO;
  let app: INestApplication;
  let rdb: Knex;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [RDBModule],
      providers: [ShipmentDAO],
    }).compile();

    rdb = await moduleRef.get<Knex>(ProviderIdentity);
    app = moduleRef.createNestApplication();

    await Promise.all([
      app.init(),
      rdb.transaction(async (trx) => {
        await trx.raw('SET CONSTRAINTS ALL DEFERRED');
        await trx.seed.run({
          directory: resolve(__dirname, './fixtures/seeds'),
          specific: 'shipment.ts',
        });
        await trx.raw('SET CONSTRAINTS ALL IMMEDIATE');
      }),
    ]);

    shipmentDAO = await moduleRef.get<ShipmentDAO>(ShipmentDAO);
  });

  describe('saveShipments', () => {
    it('複数のshipmentを一括保存できる', async () => {
      const shipmentId1 = uuidv7();
      const shipmentId2 = uuidv7();

      const shipments = [
        {
          id: shipmentId1,
          organizationId: 'test-org-1',
          slipId: 'slip-001',
          consignor: { id: 'consignor-1', name: '発荷主A' },
          consignee: { id: 'consignee-1', name: '着荷主A' },
          originSpotId: 'spot-origin-1',
          destinationSpotId: 'spot-dest-1',
          meta: { note: 'テストメタデータ' },
        },
        {
          id: shipmentId2,
          organizationId: 'test-org-1',
          slipId: 'slip-002',
          consignor: { id: 'consignor-2', name: '発荷主B' },
          consignee: { id: 'consignee-2', name: '着荷主B' },
          originSpotId: 'spot-origin-2',
          destinationSpotId: 'spot-dest-2',
        },
      ];

      await shipmentDAO.saveShipments(shipments);

      const results = await rdb
        .from('shipment')
        .whereIn('id', [shipmentId1, shipmentId2])
        .orderBy('slip_id', 'asc');

      expect(results).toHaveLength(2);
      expect(results[0]).toMatchObject({
        id: shipmentId1,
        organization_id: 'test-org-1',
        slip_id: 'slip-001',
        origin_spot_id: 'spot-origin-1',
        destination_spot_id: 'spot-dest-1',
      });
      expect(results[0].consignor).toEqual({
        id: 'consignor-1',
        name: '発荷主A',
      });
      expect(results[0].consignee).toEqual({
        id: 'consignee-1',
        name: '着荷主A',
      });
      expect(results[0].meta).toEqual({ note: 'テストメタデータ' });
      expect(results[1].meta).toBeNull();
    });

    it('空配列の場合は何もしない', async () => {
      const beforeCount = await rdb.from('shipment').count('* as count');

      await shipmentDAO.saveShipments([]);

      const afterCount = await rdb.from('shipment').count('* as count');
      expect(afterCount[0].count).toBe(beforeCount[0].count);
    });

    it('例外が正常にスローされる', async () => {
      await expect(
        async () =>
          await shipmentDAO.saveShipments([
            {
              id: uuidv7(),
              organizationId: 'non-existent-org',
              slipId: 'slip-999',
              consignor: { id: 'c1', name: 'C1' },
              consignee: { id: 'c2', name: 'C2' },
              originSpotId: 'spot-1',
              destinationSpotId: 'spot-2',
            },
          ])
      ).rejects.toThrow('シップメント情報の保存に失敗しました。');
    });
  });

  describe('getShipments', () => {
    it('指定した組織のshipmentを取得できる', async () => {
      const results = await shipmentDAO.getShipments('test-org-1', 10, 0);

      expect(results).toHaveLength(5);
      expect(results[0].organizationId).toBe('test-org-1');
      expect(results[0].slipId).toBe('SLIP-ORG1-005'); // 最新のものが最初
    });

    it('limitとoffsetで正しくページネーションできる', async () => {
      const firstPage = await shipmentDAO.getShipments('test-org-1', 2, 0);
      const secondPage = await shipmentDAO.getShipments('test-org-1', 2, 2);

      expect(firstPage).toHaveLength(2);
      expect(secondPage).toHaveLength(2);
      expect(firstPage[0].slipId).toBe('SLIP-ORG1-005');
      expect(firstPage[1].slipId).toBe('SLIP-ORG1-004');
      expect(secondPage[0].slipId).toBe('SLIP-ORG1-003');
      expect(secondPage[1].slipId).toBe('SLIP-ORG1-002');
    });

    it('created_atの降順でソートされる', async () => {
      const results = await shipmentDAO.getShipments('test-org-1', 10, 0);

      for (let i = 0; i < results.length - 1; i++) {
        const current = results[i].slipId;
        const next = results[i + 1].slipId;
        // SLIP-ORG1-005, SLIP-ORG1-004, ... の順
        expect(parseInt(current.split('-')[2])).toBeGreaterThan(
          parseInt(next.split('-')[2])
        );
      }
    });

    it('組織IDでフィルタリングされる', async () => {
      const org1Results = await shipmentDAO.getShipments('test-org-1', 10, 0);
      const org2Results = await shipmentDAO.getShipments('test-org-2', 10, 0);

      expect(org1Results).toHaveLength(5);
      expect(org2Results).toHaveLength(3);
      org1Results.forEach((r) => expect(r.organizationId).toBe('test-org-1'));
      org2Results.forEach((r) => expect(r.organizationId).toBe('test-org-2'));
    });

    it('データが存在しない場合は空配列を返す', async () => {
      const results = await shipmentDAO.getShipments('non-existent-org', 10, 0);

      expect(results).toEqual([]);
    });

    it('offsetが全件数を超えた場合は空配列を返す', async () => {
      const results = await shipmentDAO.getShipments('test-org-1', 10, 100);

      expect(results).toEqual([]);
    });

    it('metaがnullの場合も正しく取得できる', async () => {
      const results = await shipmentDAO.getShipments('test-org-1', 10, 0);
      const withoutMeta = results.find((r) => r.slipId === 'SLIP-ORG1-002');

      expect(withoutMeta).toBeDefined();
      expect(withoutMeta?.meta).toBeNull();
    });

    it('metaが存在する場合はオブジェクトとして取得できる', async () => {
      const results = await shipmentDAO.getShipments('test-org-1', 10, 0);
      const withMeta = results.find((r) => r.slipId === 'SLIP-ORG1-001');

      expect(withMeta).toBeDefined();
      expect(withMeta?.meta).toHaveProperty('weight');
      expect(withMeta?.meta).toHaveProperty('volume');
    });
  });

  describe('saveShipmentEvents', () => {
    let testShipmentId: string;

    beforeEach(async () => {
      const shipments = await rdb.from('shipment').where('organization_id', 'test-org-1').limit(1);
      testShipmentId = shipments[0].id;
    });

    it('複数のイベントと状態を一括保存できる', async () => {
      const eventId1 = uuidv7();
      const eventId2 = uuidv7();
      const executedAt = new Date();

      const events = [
        {
          id: eventId1,
          shipmentId: testShipmentId,
          type: SHIPMENT_EVENT_TYPE.STORE,
          originalSpotId: 'spot-001',
          geocode: { x: 139.7671, y: 35.6812 },
          updateBy: 'test-user-1',
          executedAt,
        },
        {
          id: eventId2,
          shipmentId: testShipmentId,
          type: SHIPMENT_EVENT_TYPE.DELIVER,
          originalSpotId: 'spot-002',
          geocode: null,
          updateBy: 'test-user-1',
          executedAt: new Date(executedAt.getTime() + 1000),
        },
      ];

      const statuses = [
        {
          shipmentId: testShipmentId,
          status: SHIPMENT_STATUS.IN_STORAGE,
          executedAt,
        },
        {
          shipmentId: testShipmentId,
          status: SHIPMENT_STATUS.COMPLETED,
          executedAt: new Date(executedAt.getTime() + 1000),
        },
      ];

      await shipmentDAO.saveShipmentEvents(events, statuses);

      const savedEvents = await rdb
        .from('shipment_event')
        .whereIn('id', [eventId1, eventId2])
        .orderBy('executed_at', 'asc');

      expect(savedEvents).toHaveLength(2);
      expect(savedEvents[0]).toMatchObject({
        id: eventId1,
        shipment_id: testShipmentId,
        type: SHIPMENT_EVENT_TYPE.STORE,
        original_spot_id: 'spot-001',
        update_by: 'test-user-1',
      });
      expect(savedEvents[0].geocode).toBeDefined();
      expect(savedEvents[1].geocode).toBeNull();

      const savedStatus = await rdb
        .from('shipment_status')
        .where('shipment_id', testShipmentId)
        .first();

      expect(savedStatus.status).toBe(SHIPMENT_STATUS.COMPLETED);
    });

    it('空配列の場合は何もしない', async () => {
      const beforeEventCount = await rdb.from('shipment_event').count('* as count');

      await shipmentDAO.saveShipmentEvents([], []);

      const afterEventCount = await rdb.from('shipment_event').count('* as count');
      expect(afterEventCount[0].count).toBe(beforeEventCount[0].count);
    });

    it('statusのUPSERTが正しく動作する', async () => {
      const executedAt1 = new Date();
      const executedAt2 = new Date(executedAt1.getTime() + 1000);

      const events1 = [
        {
          id: uuidv7(),
          shipmentId: testShipmentId,
          type: SHIPMENT_EVENT_TYPE.STORE,
          originalSpotId: 'spot-001',
          geocode: null,
          updateBy: 'test-user-1',
          executedAt: executedAt1,
        },
      ];

      const statuses1 = [
        {
          shipmentId: testShipmentId,
          status: SHIPMENT_STATUS.IN_STORAGE,
          executedAt: executedAt1,
        },
      ];

      await shipmentDAO.saveShipmentEvents(events1, statuses1);

      const statusAfterFirst = await rdb
        .from('shipment_status')
        .where('shipment_id', testShipmentId)
        .first();

      expect(statusAfterFirst.status).toBe(SHIPMENT_STATUS.IN_STORAGE);

      const events2 = [
        {
          id: uuidv7(),
          shipmentId: testShipmentId,
          type: SHIPMENT_EVENT_TYPE.DELIVER,
          originalSpotId: 'spot-002',
          geocode: null,
          updateBy: 'test-user-1',
          executedAt: executedAt2,
        },
      ];

      const statuses2 = [
        {
          shipmentId: testShipmentId,
          status: SHIPMENT_STATUS.COMPLETED,
          executedAt: executedAt2,
        },
      ];

      await shipmentDAO.saveShipmentEvents(events2, statuses2);

      const statusAfterSecond = await rdb
        .from('shipment_status')
        .where('shipment_id', testShipmentId)
        .first();

      expect(statusAfterSecond.status).toBe(SHIPMENT_STATUS.COMPLETED);

      const eventCount = await rdb
        .from('shipment_event')
        .where('shipment_id', testShipmentId)
        .count('* as count');

      expect(eventCount[0].count).toBe('2');
    });

    it('例外が正常にスローされる', async () => {
      await expect(
        async () =>
          await shipmentDAO.saveShipmentEvents(
            [
              {
                id: uuidv7(),
                shipmentId: 'non-existent-shipment',
                type: SHIPMENT_EVENT_TYPE.STORE,
                originalSpotId: 'spot-001',
                geocode: null,
                updateBy: 'test-user-1',
                executedAt: new Date(),
              },
            ],
            []
          )
      ).rejects.toThrow('シップメントイベント情報の保存に失敗しました。');
    });
  });

  afterEach(() => {
    rdb.destroy();
  });
});
