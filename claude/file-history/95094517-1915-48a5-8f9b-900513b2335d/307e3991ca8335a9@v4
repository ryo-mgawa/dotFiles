import { Logger } from '@app/logger';
import { ProviderIdentity } from '@app/rdb';
import { Inject, Injectable } from '@nestjs/common';
import { Knex } from 'knex';
import { ShipmentConflictException } from '../../exception/shipmentConflictException';
import { ShipmentSaveException } from '../../exception/shipmentSaveException';
import { Shipment } from '../model/shipment';
import { SaveShipment } from './types/saveShipment';

const POSTGRES_UNIQUE_VIOLATION = '23505';

@Injectable()
export class ShipmentDAO {
  constructor(@Inject(ProviderIdentity) private rdb: Knex) { }

  public async save(shipments: SaveShipment[]): Promise<void> {
    if (shipments.length === 0) {
      return;
    }

    const records = shipments.map((shipment) => ({
      id: shipment.id,
      organization_id: shipment.organizationId,
      slip_id: shipment.slipId,
      consignor: JSON.stringify(shipment.consignor),
      consignee: JSON.stringify(shipment.consignee),
      origin_spot_id: shipment.originSpotId,
      destination_spot_id: shipment.destinationSpotId,
      meta: shipment.meta ? JSON.stringify(shipment.meta) : null,
    }));

    try {
      await this.rdb.transaction(async (trx) => {
        await trx('shipment').insert(records);
      });
    } catch (error: any) {
      Logger.error(error);

      if (error.code !== POSTGRES_UNIQUE_VIOLATION) {
        throw new ShipmentSaveException('シップメント情報の保存に失敗しました。');
      }

      const constraintName = error.constraint || '';

      if (constraintName.includes('pkey') || constraintName.includes('_id_')) {
        throw new ShipmentConflictException('指定されたIDは既に存在します。');
      }

      if (constraintName.includes('slip_id') && constraintName.includes('organization_id')) {
        throw new ShipmentConflictException('指定された伝票IDと組織IDの組み合わせは既に存在します。');
      }

      throw new ShipmentConflictException('シップメント情報が既に存在します。');
    }
  }

  public async getShipments(
    organizationId: string,
    limit: number,
    offset: number
  ): Promise<Shipment[]> {
    const records = await this.rdb
      .from('shipment')
      .where('organization_id', organizationId)
      .orderBy('created_at', 'desc')
      .limit(limit)
      .offset(offset)
      .select(
        'id',
        'organization_id',
        'slip_id',
        'consignor',
        'consignee',
        'origin_spot_id',
        'destination_spot_id',
        'meta'
      );

    return records.map((record) => ({
      id: record.id,
      organizationId: record.organization_id,
      slipId: record.slip_id,
      consignor: record.consignor,
      consignee: record.consignee,
      originSpotId: record.origin_spot_id,
      destinationSpotId: record.destination_spot_id,
      meta: record.meta,
    }));
  }
}
