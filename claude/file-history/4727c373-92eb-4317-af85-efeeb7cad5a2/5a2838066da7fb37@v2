import type { Participant } from '@/entities';
import type { IVideoService, VideoRenderOptions } from './IVideoService';
import type { VideoConnectionConfig, VolumeLevel } from '../types';
import type { VideoSessionObserver } from '../observers';
import { VideoSessionSubject } from '../observers';

/**
 * テスト用モックビデオアダプター
 * Zoom SDKを使用せずにビデオ機能をシミュレートする
 */
export class MockVideoAdapter implements IVideoService {
  private connected = false;
  private audioOn = false;
  private videoOn = false;
  private participants: Participant[] = [];
  private subject: VideoSessionSubject = new VideoSessionSubject();

  async connect(_config: VideoConnectionConfig): Promise<void> {
    // 接続をシミュレート
    await this.delay(500);
    this.connected = true;
    this.audioOn = true;
    this.videoOn = true;
  }

  async disconnect(): Promise<void> {
    await this.delay(100);
    this.connected = false;
    this.audioOn = false;
    this.videoOn = false;
    this.participants = [];
    this.subject.clear();
  }

  async toggleAudio(): Promise<boolean> {
    this.audioOn = !this.audioOn;
    return this.audioOn;
  }

  async toggleVideo(): Promise<boolean> {
    this.videoOn = !this.videoOn;
    return this.videoOn;
  }

  async setVolume(_participantId: string, _level: VolumeLevel): Promise<void> {
    // モック実装では何もしない
  }

  getParticipants(): Participant[] {
    return [...this.participants];
  }

  subscribeToEvents(observer: VideoSessionObserver): () => void {
    return this.subject.subscribe(observer);
  }

  isConnected(): boolean {
    return this.connected;
  }

  isAudioOn(): boolean {
    return this.audioOn;
  }

  isVideoOn(): boolean {
    return this.videoOn;
  }

  async renderVideo(_options: VideoRenderOptions): Promise<void> {
    // モック実装: キャンバスに色を塗る
    const ctx = _options.canvas.getContext('2d');
    if (ctx) {
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, _options.width, _options.height);
      ctx.fillStyle = '#fff';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Video Mock', _options.width / 2, _options.height / 2);
    }
  }

  async stopRenderVideo(_participantId: string, canvas: HTMLCanvasElement): Promise<void> {
    // モック実装: キャンバスをクリア
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  }

  async renderSelfVideo(canvas: HTMLCanvasElement, width: number, height: number): Promise<void> {
    // モック実装: セルフビュー用の色
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = '#888';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Self View', width / 2, height / 2);
    }
  }

  async stopRenderSelfVideo(): Promise<void> {
    // モック実装では何もしない
  }

  // テスト用ヘルパーメソッド

  /**
   * 参加者の参加をシミュレート
   */
  simulateParticipantJoin(participant: Participant): void {
    this.participants.push(participant);
    this.subject.notify({
      type: 'PARTICIPANT_JOIN',
      participant,
      timestamp: new Date(),
    });
  }

  /**
   * 参加者の離脱をシミュレート
   */
  simulateParticipantLeave(participantId: string): void {
    const participant = this.participants.find(p => p.id === participantId);
    if (participant) {
      this.participants = this.participants.filter(p => p.id !== participantId);
      this.subject.notify({
        type: 'PARTICIPANT_LEAVE',
        participant,
        timestamp: new Date(),
      });
    }
  }

  /**
   * 参加者の状態更新をシミュレート
   */
  simulateParticipantUpdate(participant: Participant): void {
    const index = this.participants.findIndex(p => p.id === participant.id);
    if (index !== -1) {
      this.participants[index] = participant;
      this.subject.notify({
        type: 'PARTICIPANT_UPDATE',
        participant,
        timestamp: new Date(),
      });
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
