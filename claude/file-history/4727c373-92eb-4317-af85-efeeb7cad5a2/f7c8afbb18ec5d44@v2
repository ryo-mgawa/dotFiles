import ZoomVideo, { type VideoClient, type Stream, VideoQuality } from '@zoom/videosdk';
import type { Participant } from '@/entities';
import { VideoSessionSubject } from '../observers';

/**
 * Zoom参加者型（SDK内部型）
 */
interface ZoomParticipant {
  oderId: number;
  displayName: string;
  bVideoOn: boolean;
  muted: boolean;
  isHost: boolean;
}

/**
 * セッション設定
 */
interface SessionConfig {
  topic: string;
  token: string;
  userName: string;
  videoQuality?: VideoQuality;
}

/**
 * Zoom Video SDK Facade
 * 複雑なZoom SDKのAPIを、アプリケーション固有のシンプルなインターフェースで隠蔽
 */
export class ZoomVideoFacade {
  private client: typeof VideoClient | null = null;
  private mediaStream: typeof Stream | null = null;
  private sessionSubject: VideoSessionSubject;
  private isInitialized = false;
  private audioStarted = false;
  private videoStarted = false;

  constructor(sessionSubject?: VideoSessionSubject) {
    this.sessionSubject = sessionSubject ?? new VideoSessionSubject();
  }

  /**
   * セッションに参加
   */
  async joinSession(config: SessionConfig): Promise<void> {
    this.client = ZoomVideo.createClient();

    await this.client.init('ja-JP', 'Global', { patchJsMedia: true });
    this.isInitialized = true;

    await this.client.join(config.topic, config.token, config.userName);

    this.mediaStream = this.client.getMediaStream();
    this.setupEventListeners();
  }

  /**
   * セッションから離脱
   */
  async leaveSession(): Promise<void> {
    if (!this.client) return;

    try {
      if (this.videoStarted && this.mediaStream) {
        await this.mediaStream.stopVideo();
      }
      if (this.audioStarted && this.mediaStream) {
        await this.mediaStream.stopAudio();
      }
      await this.client.leave();
    } finally {
      this.cleanup();
    }
  }

  /**
   * マイクのオン/オフを切り替え
   * @returns 切り替え後のミュート状態（true: ミュート解除, false: ミュート）
   */
  async toggleMicrophone(): Promise<boolean> {
    if (!this.mediaStream) {
      throw new Error('Not connected');
    }

    if (!this.audioStarted) {
      await this.mediaStream.startAudio();
      this.audioStarted = true;
      return true;
    }

    const isMuted = this.mediaStream.isAudioMuted();
    if (isMuted) {
      await this.mediaStream.unmuteAudio();
    } else {
      await this.mediaStream.muteAudio();
    }
    return isMuted;
  }

  /**
   * カメラのオン/オフを切り替え
   * @returns 切り替え後のビデオ状態（true: オン, false: オフ）
   */
  async toggleCamera(): Promise<boolean> {
    if (!this.mediaStream) {
      throw new Error('Not connected');
    }

    if (!this.videoStarted) {
      await this.mediaStream.startVideo({
        videoQuality: VideoQuality.Video_1080P,
      });
      this.videoStarted = true;
      return true;
    }

    const isCapturing = this.mediaStream.isCapturingVideo();
    if (isCapturing) {
      await this.mediaStream.stopVideo();
      this.videoStarted = false;
    } else {
      await this.mediaStream.startVideo({
        videoQuality: VideoQuality.Video_1080P,
      });
      this.videoStarted = true;
    }
    return !isCapturing;
  }

  /**
   * 参加者の音量を設定
   */
  async setParticipantVolume(participantId: string, volume: number): Promise<void> {
    if (!this.mediaStream) {
      throw new Error('Not connected');
    }
    // Zoom SDKの音量調整API（0-100の範囲）
    await this.mediaStream.adjustUserAudioVolumeLocally(Number(participantId), volume);
  }

  /**
   * 現在の参加者一覧を取得
   */
  getParticipants(): Participant[] {
    if (!this.client) return [];

    const users = this.client.getAllUser() as ZoomParticipant[];
    return users.map(user => this.mapToParticipant(user));
  }

  /**
   * オブザーバーを登録
   */
  subscribe(observer: Parameters<VideoSessionSubject['subscribe']>[0]): () => void {
    return this.sessionSubject.subscribe(observer);
  }

  /**
   * セッションサブジェクトを取得
   */
  getSessionSubject(): VideoSessionSubject {
    return this.sessionSubject;
  }

  /**
   * オーディオ状態を取得
   */
  isAudioMuted(): boolean {
    if (!this.mediaStream || !this.audioStarted) return true;
    return this.mediaStream.isAudioMuted();
  }

  /**
   * ビデオ状態を取得
   */
  isCapturingVideo(): boolean {
    if (!this.mediaStream || !this.videoStarted) return false;
    return this.mediaStream.isCapturingVideo();
  }

  /**
   * 初期化状態を取得
   */
  isSessionInitialized(): boolean {
    return this.isInitialized;
  }

  /**
   * イベントリスナーを設定
   */
  private setupEventListeners(): void {
    if (!this.client) return;

    this.client.on('user-added', (users: ZoomParticipant[]) => {
      users.forEach(user => {
        this.sessionSubject.notify({
          type: 'PARTICIPANT_JOIN',
          participant: this.mapToParticipant(user),
          timestamp: new Date(),
        });
      });
    });

    this.client.on('user-removed', (users: ZoomParticipant[]) => {
      users.forEach(user => {
        this.sessionSubject.notify({
          type: 'PARTICIPANT_LEAVE',
          participant: this.mapToParticipant(user),
          timestamp: new Date(),
        });
      });
    });

    this.client.on('user-updated', (users: ZoomParticipant[]) => {
      users.forEach(user => {
        this.sessionSubject.notify({
          type: 'PARTICIPANT_UPDATE',
          participant: this.mapToParticipant(user),
          timestamp: new Date(),
        });
      });
    });
  }

  /**
   * Zoom参加者をアプリケーション参加者に変換
   */
  private mapToParticipant(sdkUser: ZoomParticipant): Participant {
    return {
      id: String(sdkUser.oderId),
      name: sdkUser.displayName,
      siteId: '', // 拠点IDは別途マッピングが必要
      isVideoOn: sdkUser.bVideoOn,
      isAudioOn: !sdkUser.muted,
    };
  }

  /**
   * 参加者のビデオをキャンバスにレンダリング
   */
  async renderVideo(
    participantId: string,
    canvas: HTMLCanvasElement,
    width: number,
    height: number
  ): Promise<void> {
    if (!this.mediaStream) {
      throw new Error('Not connected');
    }
    await this.mediaStream.renderVideo(
      canvas,
      Number(participantId),
      width,
      height,
      0,
      0,
      VideoQuality.Video_1080P
    );
  }

  /**
   * 参加者のビデオレンダリングを停止
   */
  async stopRenderVideo(participantId: string, canvas: HTMLCanvasElement): Promise<void> {
    if (!this.mediaStream) {
      return;
    }
    await this.mediaStream.stopRenderVideo(canvas, Number(participantId));
  }

  /**
   * 自分のビデオをキャンバスにレンダリング
   */
  async renderSelfVideo(
    canvas: HTMLCanvasElement,
    width: number,
    height: number
  ): Promise<void> {
    if (!this.mediaStream || !this.client) {
      throw new Error('Not connected');
    }
    const currentUser = this.client.getCurrentUserInfo();
    if (currentUser) {
      await this.mediaStream.renderVideo(
        canvas,
        currentUser.oderId,
        width,
        height,
        0,
        0,
        VideoQuality.Video_720P
      );
    }
  }

  /**
   * 自分のビデオレンダリングを停止
   */
  async stopRenderSelfVideo(canvas?: HTMLCanvasElement): Promise<void> {
    if (!this.mediaStream || !this.client) {
      return;
    }
    const currentUser = this.client.getCurrentUserInfo();
    if (currentUser && canvas) {
      await this.mediaStream.stopRenderVideo(canvas, currentUser.oderId);
    }
  }

  /**
   * MediaStreamを取得
   */
  getMediaStream(): typeof Stream | null {
    return this.mediaStream;
  }

  /**
   * リソースのクリーンアップ
   */
  private cleanup(): void {
    this.sessionSubject.clear();
    this.mediaStream = null;
    this.client = null;
    this.isInitialized = false;
    this.audioStarted = false;
    this.videoStarted = false;
  }
}
