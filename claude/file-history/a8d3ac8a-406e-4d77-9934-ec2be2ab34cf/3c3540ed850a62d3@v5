// Supabase Edge Function for Slack IT Request
// Denoç’°å¢ƒã§å‹•ä½œã—ã¾ã™

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { getCommonSlackCredentials, verifySlackSignature, checkChannelAndRespond } from "../_shared/slack-common.ts";

// å…±é€šã®Slackèªè¨¼æƒ…å ±ã‚’å–å¾—
const { SLACK_BOT_TOKEN, SLACK_SIGNING_SECRET } = getCommonSlackCredentials();

// ã‚¢ãƒ—ãƒªå›ºæœ‰ã®ç’°å¢ƒå¤‰æ•°ã®å–å¾—
const TEAM_USERGROUP_ID = Deno.env.get("IT_REQUEST_TEAM_USERGROUP_ID");
const NOTION_TOKEN = Deno.env.get("NOTION_TOKEN"); // å…±é€šåŒ–
const NOTION_DATABASE_ID = Deno.env.get("IT_REQUEST_NOTION_DATABASE_ID");

// å¿…é ˆç’°å¢ƒå¤‰æ•°ã®ãƒã‚§ãƒƒã‚¯
if (!TEAM_USERGROUP_ID) {
  throw new Error("å¿…é ˆã®ç’°å¢ƒå¤‰æ•°ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“: IT_REQUEST_TEAM_USERGROUP_ID");
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’å–å¾—ã™ã‚‹é–¢æ•°
 */
async function getTeamMembers(): Promise<string[]> {
  try {
    // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å«ã‚€URLã‚’æ§‹ç¯‰
    const url = new URL("https://slack.com/api/usergroups.users.list");
    url.searchParams.append("usergroup", TEAM_USERGROUP_ID);

    const response = await fetch(url.toString(), {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
    });

    const data = await response.json();

    if (!data.ok) {
      console.error("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—ãƒ¡ãƒ³ãƒãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼:", data.error);
      return [];
    }

    return data.users || [];
  } catch (error) {
    console.error("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—ãƒ¡ãƒ³ãƒãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼:", error);
    return [];
  }
}

// Notioné€£æºãŒæœ‰åŠ¹ã‹ã©ã†ã‹
const NOTION_ENABLED = !!(NOTION_TOKEN && NOTION_DATABASE_ID);

/**
 * ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ•ã‚©ãƒ¼ãƒ ã‚’é–‹ã
 */
async function openModal(triggerId: string, channelId: string): Promise<{ success: boolean; error?: string }> {
  try {
    const modal = {
      type: "modal",
      callback_id: "it_request_modal",
      private_metadata: JSON.stringify({ channel: channelId }),
      title: {
        type: "plain_text",
        text: "æƒ…ã‚·ã‚¹ãƒªã‚¯ã‚¨ã‚¹ãƒˆ",
      },
      submit: {
        type: "plain_text",
        text: "é€ä¿¡ã™ã‚‹",
      },
      close: {
        type: "plain_text",
        text: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
      },
      blocks: [
        {
          type: "input",
          block_id: "summary_block",
          element: {
            type: "plain_text_input",
            action_id: "summary",
            placeholder: {
              type: "plain_text",
              text: "ä¾‹: æ–°ã—ã„PCã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—",
            },
          },
          label: {
            type: "plain_text",
            text: "ãƒªã‚¯ã‚¨ã‚¹ãƒˆå†…å®¹ï¼ˆæ¦‚è¦ï¼‰",
          },
        },
        {
          type: "input",
          block_id: "detail_block",
          element: {
            type: "plain_text_input",
            action_id: "detail",
            multiline: true,
            placeholder: {
              type: "plain_text",
              text: "ä¾‹: Windows 11ã®PCã‚’1å°ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¦ã»ã—ã„ã§ã™ã€‚é–‹ç™ºç”¨ã®ç’°å¢ƒã‚‚å«ã‚ã¦ãŠé¡˜ã„ã—ã¾ã™ã€‚",
            },
          },
          label: {
            type: "plain_text",
            text: "ãƒªã‚¯ã‚¨ã‚¹ãƒˆå†…å®¹ï¼ˆè©³ç´°ï¼‰",
          },
        },
        {
          type: "input",
          block_id: "priority_block",
          element: {
            type: "static_select",
            action_id: "priority",
            placeholder: {
              type: "plain_text",
              text: "å„ªå…ˆåº¦ã‚’é¸æŠã—ã¦ãã ã•ã„",
            },
            options: [
              {
                text: {
                  type: "plain_text",
                  text: "ã™ã",
                },
                value: "ã™ã",
              },
              {
                text: {
                  type: "plain_text",
                  text: "2,3æ—¥ä»¥å†…",
                },
                value: "2,3æ—¥ä»¥å†…",
              },
              {
                text: {
                  type: "plain_text",
                  text: "ä¸€é€±é–“ä»¥å†…",
                },
                value: "ä¸€é€±é–“ä»¥å†…",
              },
              {
                text: {
                  type: "plain_text",
                  text: "ãã®ã†ã¡",
                },
                value: "ãã®ã†ã¡",
              },
            ],
          },
          label: {
            type: "plain_text",
            text: "å„ªå…ˆåº¦",
          },
        },
      ],
    };

    const response = await fetch("https://slack.com/api/views.open", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
      body: JSON.stringify({
        trigger_id: triggerId,
        view: modal,
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºã‚¨ãƒ©ãƒ¼:", result.error);
      return { success: false, error: result.error };
    }

    return { success: true };
  } catch (error) {
    console.error("ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºä¾‹å¤–:", error);
    return { success: false, error: "ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã—ãŸ" };
  }
}

/**
 * ãƒãƒ£ãƒ³ãƒãƒ«ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
 */
async function postMessage(
  channel: string,
  summary: string,
  detail: string,
  priority: string,
  userId: string
): Promise<{ success: boolean; ts?: string }> {
  try {
    const timestamp = new Date().toLocaleString("ja-JP", { timeZone: "Asia/Tokyo" });

    const text = `ğŸ« *æƒ…ã‚·ã‚¹ãƒªã‚¯ã‚¨ã‚¹ãƒˆ*\n\n` +
      `*ãƒªã‚¯ã‚¨ã‚¹ãƒˆè€…:* <@${userId}>\n` +
      `*ãƒªã‚¯ã‚¨ã‚¹ãƒˆå†…å®¹:* ${summary}\n` +
      `*è©³ç´°:*\n${detail}\n` +
      `*å„ªå…ˆåº¦:* ${priority}\n` +
      `*ç”³è«‹æ—¥æ™‚:* ${timestamp}`;

    const response = await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
      body: JSON.stringify({
        channel: channel,
        text: text,
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", result.error);
      return { success: false };
    }

    return { success: true, ts: result.ts };
  } catch (error) {
    console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ä¾‹å¤–:", error);
    return { success: false };
  }
}

/**
 * ã‚¹ãƒ¬ãƒƒãƒ‰ã«ç¢ºèªæ¸ˆã¿ãƒœã‚¿ãƒ³ã‚’æŠ•ç¨¿
 */
async function postConfirmRequest(
  channel: string,
  threadTs: string
): Promise<boolean> {
  try {
    const text = `æƒ…ã‚·ã‚¹ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã¯ç¢ºèªãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`;

    const response = await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
      body: JSON.stringify({
        channel: channel,
        thread_ts: threadTs,
        text: text,
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: text,
            },
          },
          {
            type: "actions",
            elements: [
              {
                type: "button",
                text: {
                  type: "plain_text",
                  text: "ç¢ºèªæ¸ˆã¿",
                },
                style: "primary",
                action_id: "confirm",
                value: JSON.stringify({}),
              },
            ],
          },
        ],
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("ç¢ºèªä¾é ¼æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", result.error);
    }

    return result.ok;
  } catch (error) {
    console.error("ç¢ºèªä¾é ¼æŠ•ç¨¿ä¾‹å¤–:", error);
    return false;
  }
}

/**
 * ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾å¿œé–‹å§‹ãƒœã‚¿ãƒ³ã‚’æŠ•ç¨¿
 */
async function postStartRequest(
  channel: string,
  threadTs: string
): Promise<boolean> {
  try {
    const text = `å¯¾å¿œã‚’é–‹å§‹ã™ã‚‹å ´åˆã¯å¯¾å¿œé–‹å§‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`;

    const response = await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
      body: JSON.stringify({
        channel: channel,
        thread_ts: threadTs,
        text: text,
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: text,
            },
          },
          {
            type: "actions",
            elements: [
              {
                type: "button",
                text: {
                  type: "plain_text",
                  text: "å¯¾å¿œé–‹å§‹",
                },
                style: "primary",
                action_id: "start",
                value: JSON.stringify({}),
              },
            ],
          },
        ],
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("å¯¾å¿œé–‹å§‹ä¾é ¼æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", result.error);
    }

    return result.ok;
  } catch (error) {
    console.error("å¯¾å¿œé–‹å§‹ä¾é ¼æŠ•ç¨¿ä¾‹å¤–:", error);
    return false;
  }
}

/**
 * ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾å¿œå®Œäº†ãƒœã‚¿ãƒ³ã‚’æŠ•ç¨¿
 */
async function postCompleteRequest(
  channel: string,
  threadTs: string
): Promise<boolean> {
  try {
    const text = `å¯¾å¿œãŒå®Œäº†ã—ãŸã‚‰å¯¾å¿œå®Œäº†ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`;

    const response = await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
      body: JSON.stringify({
        channel: channel,
        thread_ts: threadTs,
        text: text,
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: text,
            },
          },
          {
            type: "actions",
            elements: [
              {
                type: "button",
                text: {
                  type: "plain_text",
                  text: "å¯¾å¿œå®Œäº†",
                },
                style: "primary",
                action_id: "complete",
                value: JSON.stringify({}),
              },
            ],
          },
        ],
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("å¯¾å¿œå®Œäº†ä¾é ¼æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", result.error);
    }

    return result.ok;
  } catch (error) {
    console.error("å¯¾å¿œå®Œäº†ä¾é ¼æŠ•ç¨¿ä¾‹å¤–:", error);
    return false;
  }
}

/**
 * Slackã®å„ªå…ˆåº¦ã‚’Notionã®å„ªå…ˆåº¦ã«ãƒãƒƒãƒ”ãƒ³ã‚°
 */
function mapPriorityToNotion(slackPriority: string): string {
  const priorityMap: { [key: string]: string } = {
    "ã™ã": "é«˜",
    "2,3æ—¥ä»¥å†…": "ä¸­",
    "ä¸€é€±é–“ä»¥å†…": "å°",
    "ãã®ã†ã¡": "æ¥µå°",
  };
  return priorityMap[slackPriority] || slackPriority;
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å–å¾—ï¼ˆSlackãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‹ã‚‰ï¼‰
 */
async function getSlackUserName(userId: string): Promise<string> {
  try {
    const response = await fetch(`https://slack.com/api/users.info?user=${userId}`, {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
    });

    const result = await response.json();

    if (result.ok && result.user) {
      // è¡¨ç¤ºåã‚’å„ªå…ˆã€æ¬¡ã«æœ¬åã€ãƒ¦ãƒ¼ã‚¶ãƒ¼åã®é †
      let name = result.user.profile?.display_name || result.user.real_name || result.user.name || userId;
      // å…ˆé ­ã®@ã‚’é™¤å»
      if (name.startsWith('@')) {
        name = name.substring(1);
      }
      return name;
    }

    return userId;
  } catch (error) {
    console.error("ãƒ¦ãƒ¼ã‚¶ãƒ¼åå–å¾—ã‚¨ãƒ©ãƒ¼:", error);
    return userId;
  }
}

/**
 * Notionãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ 
 */
async function addToNotionDatabase(
  requesterName: string,
  requestDate: Date,
  summary: string,
  detail: string,
  priority: string,
  channel: string,
  threadTs: string
): Promise<string | null> {
  if (!NOTION_ENABLED) {
    return null;
  }

  try {
    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆï¼ˆSlack URLå½¢å¼ï¼‰
    const threadLink = `https://slack.com/archives/${channel}/${threadTs.replace('.', '')}`;

    // Slackã®å„ªå…ˆåº¦ã‚’Notionã®å„ªå…ˆåº¦ã«ãƒãƒƒãƒ”ãƒ³ã‚°
    const notionPriority = mapPriorityToNotion(priority);

    const response = await fetch("https://api.notion.com/v1/pages", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${NOTION_TOKEN}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        parent: { database_id: NOTION_DATABASE_ID },
        properties: {
          "ãƒªã‚¯ã‚¨ã‚¹ãƒˆå†…å®¹": {
            title: [
              {
                text: {
                  content: summary,
                },
              },
            ],
          },
          "ãƒªã‚¯ã‚¨ã‚¹ãƒˆè€…å": {
            rich_text: [
              {
                text: {
                  content: requesterName,
                },
              },
            ],
          },
          "ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ—¥": {
            date: {
              start: requestDate.toISOString(),
            },
          },
          "å„ªå…ˆåº¦": {
            select: {
              name: notionPriority,
            },
          },
          "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹": {
            status: {
              name: "æœªç¢ºèª",
            },
          },
          "ç¢ºèªè€…å": {
            rich_text: [],
          },
          "ç¢ºèªæ—¥": {
            date: null,
          },
          "å¯¾å¿œé–‹å§‹è€…å": {
            rich_text: [],
          },
          "å¯¾å¿œé–‹å§‹æ—¥": {
            date: null,
          },
          "å¯¾å¿œå®Œäº†è€…å": {
            rich_text: [],
          },
          "å¯¾å¿œå®Œäº†æ—¥": {
            date: null,
          },
          "ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒªãƒ³ã‚¯": {
            url: threadLink,
          },
        },
        children: [
          {
            object: "block",
            type: "paragraph",
            paragraph: {
              rich_text: [
                {
                  type: "text",
                  text: {
                    content: detail,
                  },
                },
              ],
            },
          },
        ],
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆã‚¨ãƒ©ãƒ¼:", JSON.stringify(result, null, 2));
      return null;
    }

    console.log("Notionãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæˆåŠŸ:", result.id);
    return result.id;
  } catch (error) {
    console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆä¾‹å¤–:", error);
    return null;
  }
}

/**
 * Notionãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ¤œç´¢ï¼ˆãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒªãƒ³ã‚¯ã§æ¤œç´¢ï¼‰
 */
async function findNotionRecordByThreadTs(channel: string, threadTs: string): Promise<string | null> {
  if (!NOTION_ENABLED) {
    return null;
  }

  try {
    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆ
    const threadLink = `https://slack.com/archives/${channel}/${threadTs.replace('.', '')}`;

    const response = await fetch(`https://api.notion.com/v1/databases/${NOTION_DATABASE_ID}/query`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${NOTION_TOKEN}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        filter: {
          property: "ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒªãƒ³ã‚¯",
          url: {
            equals: threadLink,
          },
        },
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ¤œç´¢ã‚¨ãƒ©ãƒ¼:", JSON.stringify(result, null, 2));
      return null;
    }

    if (result.results && result.results.length > 0) {
      return result.results[0].id;
    }

    return null;
  } catch (error) {
    console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ¤œç´¢ä¾‹å¤–:", error);
    return null;
  }
}

/**
 * Notionãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆç¢ºèªæ¸ˆã¿ï¼‰
 */
async function updateNotionRecordConfirmed(
  pageId: string,
  confirmerName: string,
  confirmDate: Date
): Promise<boolean> {
  if (!NOTION_ENABLED) {
    return false;
  }

  try {
    const response = await fetch(`https://api.notion.com/v1/pages/${pageId}`, {
      method: "PATCH",
      headers: {
        "Authorization": `Bearer ${NOTION_TOKEN}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        properties: {
          "ç¢ºèªè€…å": {
            rich_text: [
              {
                text: {
                  content: confirmerName,
                },
              },
            ],
          },
          "ç¢ºèªæ—¥": {
            date: {
              start: confirmDate.toISOString(),
            },
          },
          "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹": {
            status: {
              name: "æœªç€æ‰‹",
            },
          },
        },
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆç¢ºèªæ¸ˆã¿ï¼‰:", JSON.stringify(result, null, 2));
      return false;
    }

    console.log("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æˆåŠŸï¼ˆç¢ºèªæ¸ˆã¿ï¼‰:", pageId);
    return true;
  } catch (error) {
    console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ä¾‹å¤–ï¼ˆç¢ºèªæ¸ˆã¿ï¼‰:", error);
    return false;
  }
}

/**
 * Notionãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆå¯¾å¿œé–‹å§‹ï¼‰
 */
async function updateNotionRecordStarted(
  pageId: string,
  starterName: string,
  startDate: Date
): Promise<boolean> {
  if (!NOTION_ENABLED) {
    return false;
  }

  try {
    const response = await fetch(`https://api.notion.com/v1/pages/${pageId}`, {
      method: "PATCH",
      headers: {
        "Authorization": `Bearer ${NOTION_TOKEN}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        properties: {
          "å¯¾å¿œé–‹å§‹è€…å": {
            rich_text: [
              {
                text: {
                  content: starterName,
                },
              },
            ],
          },
          "å¯¾å¿œé–‹å§‹æ—¥": {
            date: {
              start: startDate.toISOString(),
            },
          },
          "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹": {
            status: {
              name: "å¯¾å¿œä¸­",
            },
          },
        },
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆå¯¾å¿œé–‹å§‹ï¼‰:", JSON.stringify(result, null, 2));
      return false;
    }

    console.log("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æˆåŠŸï¼ˆå¯¾å¿œé–‹å§‹ï¼‰:", pageId);
    return true;
  } catch (error) {
    console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ä¾‹å¤–ï¼ˆå¯¾å¿œé–‹å§‹ï¼‰:", error);
    return false;
  }
}

/**
 * Notionãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆå¯¾å¿œå®Œäº†ï¼‰
 */
async function updateNotionRecordCompleted(
  pageId: string,
  completerName: string,
  completeDate: Date
): Promise<boolean> {
  if (!NOTION_ENABLED) {
    return false;
  }

  try {
    const response = await fetch(`https://api.notion.com/v1/pages/${pageId}`, {
      method: "PATCH",
      headers: {
        "Authorization": `Bearer ${NOTION_TOKEN}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        properties: {
          "å¯¾å¿œå®Œäº†è€…å": {
            rich_text: [
              {
                text: {
                  content: completerName,
                },
              },
            ],
          },
          "å¯¾å¿œå®Œäº†æ—¥": {
            date: {
              start: completeDate.toISOString(),
            },
          },
          "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹": {
            status: {
              name: "å®Œäº†",
            },
          },
        },
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆå¯¾å¿œå®Œäº†ï¼‰:", JSON.stringify(result, null, 2));
      return false;
    }

    console.log("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æˆåŠŸï¼ˆå¯¾å¿œå®Œäº†ï¼‰:", pageId);
    return true;
  } catch (error) {
    console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ä¾‹å¤–ï¼ˆå¯¾å¿œå®Œäº†ï¼‰:", error);
    return false;
  }
}

/**
 * ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†
 */
async function handleSlashCommand(formData: URLSearchParams): Promise<Response> {
  const channelId = formData.get("channel_id");
  const triggerId = formData.get("trigger_id");

  // ãƒãƒ£ãƒ³ãƒãƒ«åˆ¶é™ã®ãƒã‚§ãƒƒã‚¯
  const channelCheckResponse = checkChannelAndRespond(channelId || "", "æƒ…ã‚·ã‚¹ãƒªã‚¯ã‚¨ã‚¹ãƒˆ");
  if (channelCheckResponse) {
    return channelCheckResponse;
  }

  // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
  if (!triggerId) {
    return new Response(
      JSON.stringify({
        response_type: "ephemeral",
        text: "âŒ trigger_idãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚",
      }),
      {
        headers: { "Content-Type": "application/json" },
        status: 200,
      }
    );
  }

  const result = await openModal(triggerId, channelId || "");

  if (result.success) {
    return new Response(null, { status: 200 });
  } else {
    const errorMessage = result.error === "invalid_trigger"
      ? "âŒ ã‚³ãƒãƒ³ãƒ‰ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚Œã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ `/æƒ…ã‚·ã‚¹ãƒªã‚¯ã‚¨ã‚¹ãƒˆ` ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚"
      : result.error === "not_authed" || result.error === "invalid_auth"
        ? "âŒ Bot Tokenã®èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚"
        : `âŒ ãƒ•ã‚©ãƒ¼ãƒ ã®è¡¨ç¤ºã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¨ãƒ©ãƒ¼: ${result.error || "ä¸æ˜"}`;

    return new Response(
      JSON.stringify({
        response_type: "ephemeral",
        text: errorMessage,
      }),
      {
        headers: { "Content-Type": "application/json" },
        status: 200,
      }
    );
  }
}

/**
 * ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã®å‡¦ç†
 */
async function handleInteractivity(payload: any): Promise<Response> {
  const type = payload.type;

  if (type === "view_submission") {
    // ãƒ¢ãƒ¼ãƒ€ãƒ«é€ä¿¡å‡¦ç†
    const values = payload.view.state.values;

    const summary = values.summary_block.summary.value;
    const detail = values.detail_block.detail.value;
    const priority = values.priority_block.priority.selected_option.value;

    // private_metadataã‹ã‚‰ãƒãƒ£ãƒ³ãƒãƒ«æƒ…å ±ã‚’å–å¾—
    const metadata = payload.view.private_metadata
      ? JSON.parse(payload.view.private_metadata)
      : null;

    // å…ˆã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™ï¼ˆSlackã¯3ç§’ä»¥å†…ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒå¿…è¦ï¼‰
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã¯éåŒæœŸã§å®Ÿè¡Œ
    if (metadata && metadata.channel) {
      // éåŒæœŸã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿ï¼ˆawaitã—ãªã„ï¼‰
      postMessage(
        metadata.channel,
        summary,
        detail,
        priority,
        payload.user.id
      ).then(async result => {
        if (result.success && result.ts) {
          // Notionã«ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚SlackæŠ•ç¨¿ã¯ç¶™ç¶šï¼‰
          if (NOTION_ENABLED) {
            const requesterName = await getSlackUserName(payload.user.id);
            const requestDate = new Date();

            addToNotionDatabase(
              requesterName,
              requestDate,
              summary,
              detail,
              priority,
              metadata.channel,
              result.ts
            ).catch(error => {
              console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆã‚¨ãƒ©ãƒ¼ï¼ˆéåŒæœŸï¼‰:", error);
            });
          }

          // ç¢ºèªä¾é ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
          return postConfirmRequest(metadata.channel, result.ts);
        }
      }).catch(error => {
        console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
      });
    } else {
      console.error("ãƒãƒ£ãƒ³ãƒãƒ«æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    }

    // å³åº§ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
    return new Response(null, { status: 200 });
  }

  if (type === "block_actions") {
    // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
    const action = payload.actions[0];
    const userId = payload.user.id;

    if (action.action_id === "confirm") {
      // ç¢ºèªãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸ
      const value = JSON.parse(action.value);
      const confirmed = value.confirmed || false;
      const confirmedBy = value.confirmedBy || null;

      const channel = payload.channel.id;
      const threadTs = payload.message.thread_ts || payload.message.ts;

      // æ—¢ã«ç¢ºèªæ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
      if (confirmed) {
        // æ—¢ã«ç¢ºèªæ¸ˆã¿ã®å ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: `âŒ <@${userId}> ã•ã‚“ã€æ—¢ã« <@${confirmedBy}> ãŒç¢ºèªæ¸ˆã¿ã§ã™ã€‚`,
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã‹ãƒã‚§ãƒƒã‚¯
      const teamMembers = await getTeamMembers();
      if (!teamMembers.includes(userId)) {
        // ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ä»¥å¤–ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: "âŒ æ¨©é™ã‚’æŒã¤äººã ã‘ãŒç¢ºèªãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚",
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã¾ãšãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰ã‚¹ãƒ¬ãƒƒãƒ‰ã«è¨˜éŒ²
      const messageTs = payload.message.ts;

      // å³åº§ã«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ï¼ˆchat.update APIã‚’ä½¿ç”¨ï¼‰
      await fetch("https://slack.com/api/chat.update", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
        },
        body: JSON.stringify({
          channel: channel,
          ts: messageTs,
          text: `æƒ…ã‚·ã‚¹ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã¯ç¢ºèªãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`,
          blocks: [
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `æƒ…ã‚·ã‚¹ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã¯ç¢ºèªãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`,
              },
            },
          ],
        }),
      });

      // ã‚¹ãƒ¬ãƒƒãƒ‰ã«ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
      Promise.all([
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: `âœ… <@${userId}> ãŒç¢ºèªã—ã¾ã—ãŸã€‚å¯¾å¿œã¾ã§ãŠå¾…ã¡ä¸‹ã•ã„ã€‚`,
          }),
        }),
      ]).then(async () => {
        // Notionãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒ•ãƒ­ãƒ¼ç¶™ç¶šï¼‰
        if (NOTION_ENABLED) {
          const pageId = await findNotionRecordByThreadTs(channel, threadTs);
          if (pageId) {
            const confirmerName = await getSlackUserName(userId);
            const confirmDate = new Date();
            await updateNotionRecordConfirmed(pageId, confirmerName, confirmDate).catch(error => {
              console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆç¢ºèªæ¸ˆã¿ã€éåŒæœŸï¼‰:", error);
            });
          }
        }

        // å¯¾å¿œé–‹å§‹ä¾é ¼ã‚’æŠ•ç¨¿
        return postStartRequest(channel, threadTs);
      }).catch(error => {
        console.error("ç¢ºèªè¨˜éŒ²æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
      });

      // å³åº§ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
      return new Response(null, { status: 200 });
    }

    if (action.action_id === "start") {
      // å¯¾å¿œé–‹å§‹ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸ
      const value = JSON.parse(action.value);
      const started = value.started || false;
      const startedBy = value.startedBy || null;

      const channel = payload.channel.id;
      const threadTs = payload.message.thread_ts || payload.message.ts;

      // æ—¢ã«å¯¾å¿œé–‹å§‹æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
      if (started) {
        // æ—¢ã«å¯¾å¿œé–‹å§‹æ¸ˆã¿ã®å ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: `âŒ <@${userId}> ã•ã‚“ã€æ—¢ã« <@${startedBy}> ãŒå¯¾å¿œé–‹å§‹æ¸ˆã¿ã§ã™ã€‚`,
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã‹ãƒã‚§ãƒƒã‚¯
      const teamMembers = await getTeamMembers();
      if (!teamMembers.includes(userId)) {
        // ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ä»¥å¤–ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: "âŒ æ¨©é™ã‚’æŒã¤äººã ã‘ãŒå¯¾å¿œé–‹å§‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚",
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã¾ãšãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰ã‚¹ãƒ¬ãƒƒãƒ‰ã«è¨˜éŒ²
      const messageTs = payload.message.ts;

      // å³åº§ã«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ï¼ˆchat.update APIã‚’ä½¿ç”¨ï¼‰
      await fetch("https://slack.com/api/chat.update", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
        },
        body: JSON.stringify({
          channel: channel,
          ts: messageTs,
          text: `å¯¾å¿œã‚’é–‹å§‹ã™ã‚‹å ´åˆã¯å¯¾å¿œé–‹å§‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`,
          blocks: [
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `å¯¾å¿œã‚’é–‹å§‹ã™ã‚‹å ´åˆã¯å¯¾å¿œé–‹å§‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`,
              },
            },
          ],
        }),
      });

      // ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾å¿œé–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
      fetch("https://slack.com/api/chat.postMessage", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
        },
        body: JSON.stringify({
          channel: channel,
          thread_ts: threadTs,
          text: `âœ… å¯¾å¿œé–‹å§‹ã—ã¾ã—ãŸã€‚`,
        }),
      }).then(async () => {
        // Notionãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒ•ãƒ­ãƒ¼ç¶™ç¶šï¼‰
        if (NOTION_ENABLED) {
          const pageId = await findNotionRecordByThreadTs(channel, threadTs);
          if (pageId) {
            const starterName = await getSlackUserName(userId);
            const startDate = new Date();
            await updateNotionRecordStarted(pageId, starterName, startDate).catch(error => {
              console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆå¯¾å¿œé–‹å§‹ã€éåŒæœŸï¼‰:", error);
            });
          }
        }

        // å¯¾å¿œå®Œäº†ä¾é ¼ã‚’æŠ•ç¨¿
        return postCompleteRequest(channel, threadTs);
      }).catch(error => {
        console.error("å¯¾å¿œé–‹å§‹è¨˜éŒ²æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
      });

      // å³åº§ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
      return new Response(null, { status: 200 });
    }

    if (action.action_id === "complete") {
      // å¯¾å¿œå®Œäº†ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸ
      const value = JSON.parse(action.value);
      const completed = value.completed || false;
      const completedBy = value.completedBy || null;

      const channel = payload.channel.id;
      const threadTs = payload.message.thread_ts || payload.message.ts;

      // æ—¢ã«å¯¾å¿œå®Œäº†æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
      if (completed) {
        // æ—¢ã«å¯¾å¿œå®Œäº†æ¸ˆã¿ã®å ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: `âŒ <@${userId}> ã•ã‚“ã€æ—¢ã« <@${completedBy}> ãŒå¯¾å¿œå®Œäº†æ¸ˆã¿ã§ã™ã€‚`,
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã‹ãƒã‚§ãƒƒã‚¯
      const teamMembers = await getTeamMembers();
      if (!teamMembers.includes(userId)) {
        // ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ä»¥å¤–ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: "âŒ æ¨©é™ã‚’æŒã¤äººã ã‘ãŒå¯¾å¿œå®Œäº†ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚",
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã¾ãšãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰ã‚¹ãƒ¬ãƒƒãƒ‰ã«è¨˜éŒ²
      const messageTs = payload.message.ts;

      // å³åº§ã«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ï¼ˆchat.update APIã‚’ä½¿ç”¨ï¼‰
      await fetch("https://slack.com/api/chat.update", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
        },
        body: JSON.stringify({
          channel: channel,
          ts: messageTs,
          text: `å¯¾å¿œãŒå®Œäº†ã—ãŸã‚‰å¯¾å¿œå®Œäº†ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`,
          blocks: [
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `å¯¾å¿œãŒå®Œäº†ã—ãŸã‚‰å¯¾å¿œå®Œäº†ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`,
              },
            },
          ],
        }),
      });

      // ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾å¿œå®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
      fetch("https://slack.com/api/chat.postMessage", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
        },
        body: JSON.stringify({
          channel: channel,
          thread_ts: threadTs,
          text: `âœ… å¯¾å¿œãŒå®Œäº†ã—ã¾ã—ãŸã€‚`,
        }),
      }).then(async () => {
        // Notionãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒ•ãƒ­ãƒ¼ç¶™ç¶šï¼‰
        if (NOTION_ENABLED) {
          const pageId = await findNotionRecordByThreadTs(channel, threadTs);
          if (pageId) {
            const completerName = await getSlackUserName(userId);
            const completeDate = new Date();
            await updateNotionRecordCompleted(pageId, completerName, completeDate).catch(error => {
              console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆå¯¾å¿œå®Œäº†ã€éåŒæœŸï¼‰:", error);
            });
          }
        }
      }).catch(error => {
        console.error("å¯¾å¿œå®Œäº†è¨˜éŒ²æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
      });

      // å³åº§ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
      return new Response(null, { status: 200 });
    }
  }

  return new Response(null, { status: 200 });
}

/**
 * ãƒ¡ã‚¤ãƒ³ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
 */
serve(async (req: Request) => {
  // CORSå¯¾å¿œ
  if (req.method === "OPTIONS") {
    return new Response(null, {
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, X-Slack-Request-Timestamp, X-Slack-Signature",
      },
    });
  }

  // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
  if (req.method === "GET") {
    return new Response(JSON.stringify({ status: "ok" }), {
      headers: { "Content-Type": "application/json" },
      status: 200,
    });
  }

  // POSTä»¥å¤–ã¯æ‹’å¦
  if (req.method !== "POST") {
    return new Response(JSON.stringify({ error: "Method not allowed" }), {
      headers: { "Content-Type": "application/json" },
      status: 405,
    });
  }

  try {
    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æ¤œè¨¼
    const timestamp = req.headers.get("X-Slack-Request-Timestamp");
    const signature = req.headers.get("X-Slack-Signature");

    if (!timestamp || !signature) {
      return new Response(JSON.stringify({ error: "ä¸æ­£ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ" }), {
        headers: { "Content-Type": "application/json" },
        status: 400,
      });
    }

    const body = await req.text();

    // ç½²åæ¤œè¨¼
    const isValid = await verifySlackSignature(body, timestamp, signature, SLACK_SIGNING_SECRET);
    if (!isValid) {
      return new Response(JSON.stringify({ error: "ç½²åæ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ" }), {
        headers: { "Content-Type": "application/json" },
        status: 401,
      });
    }

    // Content-Typeã‚’ç¢ºèªã—ã¦ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¿ã‚¤ãƒ—ã‚’åˆ¤åˆ¥
    const contentType = req.headers.get("Content-Type");

    if (contentType?.includes("application/x-www-form-urlencoded")) {
      const formData = new URLSearchParams(body);

      // payloadãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£
      if (formData.has("payload")) {
        const payload = JSON.parse(formData.get("payload")!);
        return await handleInteractivity(payload);
      }

      // ãã‚Œä»¥å¤–ã¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰
      return await handleSlashCommand(formData);
    }

    return new Response(JSON.stringify({ error: "ä¸æ­£ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆå½¢å¼" }), {
      headers: { "Content-Type": "application/json" },
      status: 400,
    });
  } catch (error) {
    console.error("ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ:", error);
    return new Response(
      JSON.stringify({
        response_type: "ephemeral",
        text: "âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚",
      }),
      {
        headers: { "Content-Type": "application/json" },
        status: 500,
      }
    );
  }
});
