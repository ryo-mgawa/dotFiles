// Supabase Edge Function for Slack Purchase Request
// Denoç’°å¢ƒã§å‹•ä½œã—ã¾ã™

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { getCommonSlackCredentials, verifySlackSignature, checkChannelAndRespond } from "../_shared/slack-common.ts";

// å…±é€šã®Slackèªè¨¼æƒ…å ±ã‚’å–å¾—
const { SLACK_BOT_TOKEN, SLACK_SIGNING_SECRET } = getCommonSlackCredentials();

// ã‚¢ãƒ—ãƒªå›ºæœ‰ã®ç’°å¢ƒå¤‰æ•°ã®å–å¾—
const FIRST_APPROVER_NAGOYA = Deno.env.get("PURCHASE_REQUEST_FIRST_APPROVER_NAGOYA");
const FIRST_APPROVER_TOKYO = Deno.env.get("PURCHASE_REQUEST_FIRST_APPROVER_TOKYO");
const SECOND_APPROVER = Deno.env.get("PURCHASE_REQUEST_SECOND_APPROVER");
const NOTION_TOKEN = Deno.env.get("NOTION_TOKEN"); // å…±é€šåŒ–
const NOTION_DATABASE_ID = Deno.env.get("PURCHASE_REQUEST_NOTION_DATABASE_ID");

// å¿…é ˆç’°å¢ƒå¤‰æ•°ã®ãƒã‚§ãƒƒã‚¯
if (!FIRST_APPROVER_NAGOYA || !FIRST_APPROVER_TOKYO) {
  throw new Error("å¿…é ˆã®ç’°å¢ƒå¤‰æ•°ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“");
}

// Notioné€£æºãŒæœ‰åŠ¹ã‹ã©ã†ã‹
const NOTION_ENABLED = !!(NOTION_TOKEN && NOTION_DATABASE_ID);

/**
 * ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ•ã‚©ãƒ¼ãƒ ã‚’é–‹ã
 */
async function openModal(triggerId: string, channelId: string): Promise<{ success: boolean; error?: string }> {
  try {
    const modal = {
      type: "modal",
      callback_id: "purchase_request_modal",
      private_metadata: JSON.stringify({ channel: channelId }),
      title: {
        type: "plain_text",
        text: "è³¼è²·ç”³è«‹",
      },
      submit: {
        type: "plain_text",
        text: "ç”³è«‹ã™ã‚‹",
      },
      close: {
        type: "plain_text",
        text: "ã‚­ãƒ£ãƒ³ã‚»ãƒ«",
      },
      blocks: [
        {
          type: "input",
          block_id: "item_name_block",
          element: {
            type: "plain_text_input",
            action_id: "item_name",
            placeholder: {
              type: "plain_text",
              text: "ä¾‹: ãƒãƒ¼ãƒˆãƒ‘ã‚½ã‚³ãƒ³",
            },
          },
          label: {
            type: "plain_text",
            text: "è³¼å…¥ç‰©å“å",
          },
        },
        {
          type: "input",
          block_id: "amount_block",
          element: {
            type: "plain_text_input",
            action_id: "amount",
            placeholder: {
              type: "plain_text",
              text: "ä¾‹: 150000",
            },
          },
          label: {
            type: "plain_text",
            text: "é‡‘é¡ï¼ˆå††ï¼‰",
          },
        },
        {
          type: "input",
          block_id: "url_block",
          element: {
            type: "plain_text_input",
            action_id: "url",
            placeholder: {
              type: "plain_text",
              text: "ä¾‹: https://example.com/product",
            },
          },
          label: {
            type: "plain_text",
            text: "URL",
          },
        },
        {
          type: "input",
          block_id: "purpose_block",
          optional: true,
          element: {
            type: "plain_text_input",
            action_id: "purpose",
            multiline: true,
            placeholder: {
              type: "plain_text",
              text: "ä¾‹: é–‹ç™ºä½œæ¥­ç”¨",
            },
          },
          label: {
            type: "plain_text",
            text: "ç‰©å“ã®ç”¨é€”",
          },
        },
      ],
    };

    const response = await fetch("https://slack.com/api/views.open", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
      body: JSON.stringify({
        trigger_id: triggerId,
        view: modal,
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºã‚¨ãƒ©ãƒ¼:", result.error);
      return { success: false, error: result.error };
    }

    return { success: true };
  } catch (error) {
    console.error("ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºä¾‹å¤–:", error);
    return { success: false, error: "ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã—ãŸ" };
  }
}

/**
 * ãƒãƒ£ãƒ³ãƒãƒ«ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
 */
async function postMessage(
  channel: string,
  itemName: string,
  amount: string,
  url: string,
  purpose: string,
  userId: string
): Promise<{ success: boolean; ts?: string }> {
  try {
    const purposeText = purpose ? `\n*ç‰©å“ã®ç”¨é€”:* ${purpose}` : "";
    const timestamp = new Date().toLocaleString("ja-JP", { timeZone: "Asia/Tokyo" });

    // ã‚«ãƒ³ãƒã‚’é™¤å»ã—ã¦ã‹ã‚‰æ•°å€¤ã«å¤‰æ›
    const cleanedAmount = amount.replace(/,/g, "");
    const numAmount = parseInt(cleanedAmount);

    const text = `ğŸ“ *è³¼è²·ç”³è«‹*\n\n` +
      `*ç”³è«‹è€…:* <@${userId}>\n` +
      `*è³¼å…¥ç‰©å“å:* ${itemName}\n` +
      `*é‡‘é¡:* Â¥${numAmount.toLocaleString()}\n` +
      `*URL:* ${url}${purposeText}\n` +
      `*ç”³è«‹æ—¥æ™‚:* ${timestamp}`;

    const response = await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
      body: JSON.stringify({
        channel: channel,
        text: text,
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", result.error);
      return { success: false };
    }

    return { success: true, ts: result.ts };
  } catch (error) {
    console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ä¾‹å¤–:", error);
    return { success: false };
  }
}

/**
 * ã‚¹ãƒ¬ãƒƒãƒ‰ã«æ‰¿èªä¾é ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
 */
async function postApprovalRequest(
  channel: string,
  threadTs: string,
  applicantId: string
): Promise<boolean> {
  try {
    const text = `ç”³è«‹è€…ãŒåå¤å±‹ã‚ªãƒ•ã‚£ã‚¹ãƒ¡ãƒ³ãƒãƒ¼ãªã‚‰ <@${FIRST_APPROVER_NAGOYA}> ãŒæ‰¿èªã—ã¦\n` +
      `ç”³è«‹è€…ãŒæ±äº¬ã‚ªãƒ•ã‚£ã‚¹ãƒ¡ãƒ³ãƒãƒ¼ãªã‚‰ <@${FIRST_APPROVER_TOKYO}> ãŒæ‰¿èªã—ã¦`;

    const response = await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
      body: JSON.stringify({
        channel: channel,
        thread_ts: threadTs,
        text: text,
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: text,
            },
          },
          {
            type: "actions",
            elements: [
              {
                type: "button",
                text: {
                  type: "plain_text",
                  text: "ä¸€æ¬¡æ‰¿èª",
                },
                style: "primary",
                action_id: "approve_first",
                value: JSON.stringify({
                  approvers: [FIRST_APPROVER_NAGOYA, FIRST_APPROVER_TOKYO],
                  applicant_id: applicantId,
                }),
              },
            ],
          },
        ],
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("æ‰¿èªä¾é ¼æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", result.error);
    }

    return result.ok;
  } catch (error) {
    console.error("æ‰¿èªä¾é ¼æŠ•ç¨¿ä¾‹å¤–:", error);
    return false;
  }
}

/**
 * ã‚¹ãƒ¬ãƒƒãƒ‰ã«äºŒæ¬¡æ‰¿èªä¾é ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
 */
async function postSecondApprovalRequest(
  channel: string,
  threadTs: string,
  applicantId: string
): Promise<boolean> {
  try {
    const text = `æœ€çµ‚æ‰¿èªã‚’ãŠé¡˜ã„ã—ã¾ã™: <@${SECOND_APPROVER}>`;

    const response = await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
      body: JSON.stringify({
        channel: channel,
        thread_ts: threadTs,
        text: text,
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: text,
            },
          },
          {
            type: "actions",
            elements: [
              {
                type: "button",
                text: {
                  type: "plain_text",
                  text: "æœ€çµ‚æ‰¿èª",
                },
                style: "primary",
                action_id: "approve_second",
                value: JSON.stringify({
                  approver: SECOND_APPROVER,
                  applicant_id: applicantId,
                }),
              },
            ],
          },
        ],
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("äºŒæ¬¡æ‰¿èªä¾é ¼æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", result.error);
    }

    return result.ok;
  } catch (error) {
    console.error("äºŒæ¬¡æ‰¿èªä¾é ¼æŠ•ç¨¿ä¾‹å¤–:", error);
    return false;
  }
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å–å¾—ï¼ˆSlackãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‹ã‚‰ï¼‰
 */
async function getSlackUserName(userId: string): Promise<string> {
  try {
    const response = await fetch(`https://slack.com/api/users.info?user=${userId}`, {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
    });

    const result = await response.json();

    if (result.ok && result.user) {
      // è¡¨ç¤ºåã‚’å„ªå…ˆã€æ¬¡ã«æœ¬åã€ãƒ¦ãƒ¼ã‚¶ãƒ¼åã®é †
      let name = result.user.profile?.display_name || result.user.real_name || result.user.name || userId;
      // å…ˆé ­ã®@ã‚’é™¤å»
      if (name.startsWith('@')) {
        name = name.substring(1);
      }
      return name;
    }

    return userId;
  } catch (error) {
    console.error("ãƒ¦ãƒ¼ã‚¶ãƒ¼åå–å¾—ã‚¨ãƒ©ãƒ¼:", error);
    return userId;
  }
}

/**
 * Notionãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ 
 */
async function addToNotionDatabase(
  applicantName: string,
  applicationDate: Date,
  itemName: string,
  amount: number,
  url: string,
  purpose: string,
  channel: string,
  threadTs: string
): Promise<string | null> {
  if (!NOTION_ENABLED) {
    return null;
  }

  try {
    // ç”³è«‹ã‚¹ãƒ¬ãƒƒãƒ‰ãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆï¼ˆSlack URLå½¢å¼ï¼‰
    const threadLink = `https://slack.com/archives/${channel}/${threadTs.replace('.', '')}`;

    const response = await fetch("https://api.notion.com/v1/pages", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${NOTION_TOKEN}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        parent: { database_id: NOTION_DATABASE_ID },
        properties: {
          "è³¼å…¥ç‰©å“å": {
            title: [
              {
                text: {
                  content: itemName,
                },
              },
            ],
          },
          "ç”³è«‹è€…å": {
            rich_text: [
              {
                text: {
                  content: applicantName,
                },
              },
            ],
          },
          "ç”³è«‹æ—¥": {
            date: {
              start: applicationDate.toISOString(),
            },
          },
          "é‡‘é¡": {
            number: amount,
          },
          "è³¼å…¥å“URL": {
            rich_text: [
              {
                text: {
                  content: url,
                },
              },
            ],
          },
          "ç‰©å“ã®ç”¨é€”": {
            rich_text: [
              {
                text: {
                  content: purpose,
                },
              },
            ],
          },
          "ç¬¬ä¸€æ‰¿èª": {
            checkbox: false,
          },
          "ç¬¬ä¸€æ‰¿èªæ—¥": {
            date: null,
          },
          "ç¬¬ä¸€æ‰¿èªè€…å": {
            rich_text: [],
          },
          "æœ€çµ‚æ‰¿èª": {
            checkbox: false,
          },
          "æœ€çµ‚æ‰¿èªè€…å": {
            rich_text: [],
          },
          "æœ€çµ‚æ‰¿èªæ—¥": {
            date: null,
          },
          "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹": {
            status: {
              name: "æœªæ‰¿èª",
            },
          },
          "è³¼å…¥è€…å": {
            rich_text: [],
          },
          "è³¼å…¥æ—¥": {
            date: null,
          },
          "ç”³è«‹ã‚¹ãƒ¬ãƒƒãƒ‰ãƒªãƒ³ã‚¯": {
            url: threadLink,
          },
        },
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆã‚¨ãƒ©ãƒ¼:", JSON.stringify(result, null, 2));
      return null;
    }

    console.log("Notionãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæˆåŠŸ:", result.id);
    return result.id;
  } catch (error) {
    console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆä¾‹å¤–:", error);
    return null;
  }
}

/**
 * Notionãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ¤œç´¢ï¼ˆç”³è«‹ã‚¹ãƒ¬ãƒƒãƒ‰ãƒªãƒ³ã‚¯ã§æ¤œç´¢ï¼‰
 */
async function findNotionRecordByThreadTs(channel: string, threadTs: string): Promise<string | null> {
  if (!NOTION_ENABLED) {
    return null;
  }

  try {
    // ç”³è«‹ã‚¹ãƒ¬ãƒƒãƒ‰ãƒªãƒ³ã‚¯ã‚’ç”Ÿæˆ
    const threadLink = `https://slack.com/archives/${channel}/${threadTs.replace('.', '')}`;

    const response = await fetch(`https://api.notion.com/v1/databases/${NOTION_DATABASE_ID}/query`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${NOTION_TOKEN}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        filter: {
          property: "ç”³è«‹ã‚¹ãƒ¬ãƒƒãƒ‰ãƒªãƒ³ã‚¯",
          url: {
            equals: threadLink,
          },
        },
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ¤œç´¢ã‚¨ãƒ©ãƒ¼:", JSON.stringify(result, null, 2));
      return null;
    }

    if (result.results && result.results.length > 0) {
      return result.results[0].id;
    }

    return null;
  } catch (error) {
    console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ¤œç´¢ä¾‹å¤–:", error);
    return null;
  }
}

/**
 * Notionãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆä¸€æ¬¡æ‰¿èªï¼‰
 */
async function updateNotionRecordFirstApproval(
  pageId: string,
  approverName: string,
  approvalDate: Date
): Promise<boolean> {
  if (!NOTION_ENABLED) {
    return false;
  }

  try {
    const response = await fetch(`https://api.notion.com/v1/pages/${pageId}`, {
      method: "PATCH",
      headers: {
        "Authorization": `Bearer ${NOTION_TOKEN}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        properties: {
          "ç¬¬ä¸€æ‰¿èª": {
            checkbox: true,
          },
          "ç¬¬ä¸€æ‰¿èªæ—¥": {
            date: {
              start: approvalDate.toISOString(),
            },
          },
          "ç¬¬ä¸€æ‰¿èªè€…å": {
            rich_text: [
              {
                text: {
                  content: approverName,
                },
              },
            ],
          },
          "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹": {
            status: {
              name: "ä¸€æ¬¡æ‰¿èªæ¸ˆã¿",
            },
          },
        },
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆä¸€æ¬¡æ‰¿èªï¼‰:", JSON.stringify(result, null, 2));
      return false;
    }

    console.log("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æˆåŠŸï¼ˆä¸€æ¬¡æ‰¿èªï¼‰:", pageId);
    return true;
  } catch (error) {
    console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ä¾‹å¤–ï¼ˆä¸€æ¬¡æ‰¿èªï¼‰:", error);
    return false;
  }
}

/**
 * Notionãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆæœ€çµ‚æ‰¿èªï¼‰
 */
async function updateNotionRecordFinalApproval(
  pageId: string,
  approverName: string,
  approvalDate: Date
): Promise<boolean> {
  if (!NOTION_ENABLED) {
    return false;
  }

  try {
    const response = await fetch(`https://api.notion.com/v1/pages/${pageId}`, {
      method: "PATCH",
      headers: {
        "Authorization": `Bearer ${NOTION_TOKEN}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        properties: {
          "æœ€çµ‚æ‰¿èª": {
            checkbox: true,
          },
          "æœ€çµ‚æ‰¿èªè€…å": {
            rich_text: [
              {
                text: {
                  content: approverName,
                },
              },
            ],
          },
          "æœ€çµ‚æ‰¿èªæ—¥": {
            date: {
              start: approvalDate.toISOString(),
            },
          },
          "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹": {
            status: {
              name: "æœ€çµ‚æ‰¿èªæ¸ˆã¿",
            },
          },
        },
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆæœ€çµ‚æ‰¿èªï¼‰:", JSON.stringify(result, null, 2));
      return false;
    }

    console.log("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æˆåŠŸï¼ˆæœ€çµ‚æ‰¿èªï¼‰:", pageId);
    return true;
  } catch (error) {
    console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ä¾‹å¤–ï¼ˆæœ€çµ‚æ‰¿èªï¼‰:", error);
    return false;
  }
}

/**
 * Notionãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆè³¼å…¥å®Œäº†ï¼‰
 */
async function updateNotionRecordPurchaseComplete(
  pageId: string,
  purchaserName: string,
  purchaseDate: Date
): Promise<boolean> {
  if (!NOTION_ENABLED) {
    return false;
  }

  try {
    const response = await fetch(`https://api.notion.com/v1/pages/${pageId}`, {
      method: "PATCH",
      headers: {
        "Authorization": `Bearer ${NOTION_TOKEN}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        properties: {
          "è³¼å…¥è€…å": {
            rich_text: [
              {
                text: {
                  content: purchaserName,
                },
              },
            ],
          },
          "è³¼å…¥æ—¥": {
            date: {
              start: purchaseDate.toISOString(),
            },
          },
          "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹": {
            status: {
              name: "è³¼å…¥å®Œäº†",
            },
          },
        },
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆè³¼å…¥å®Œäº†ï¼‰:", JSON.stringify(result, null, 2));
      return false;
    }

    console.log("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æˆåŠŸï¼ˆè³¼å…¥å®Œäº†ï¼‰:", pageId);
    return true;
  } catch (error) {
    console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ä¾‹å¤–ï¼ˆè³¼å…¥å®Œäº†ï¼‰:", error);
    return false;
  }
}

/**
 * ã‚¹ãƒ¬ãƒƒãƒ‰ã«è³¼å…¥å®Œäº†ä¾é ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
 */
async function postPurchaseCompleteRequest(
  channel: string,
  threadTs: string,
  applicantId: string
): Promise<boolean> {
  try {
    const text = `è³¼å…¥ã—ãŸã‚‰è³¼å…¥å®Œäº†ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`;

    const response = await fetch("https://slack.com/api/chat.postMessage", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
      },
      body: JSON.stringify({
        channel: channel,
        thread_ts: threadTs,
        text: text,
        blocks: [
          {
            type: "section",
            text: {
              type: "mrkdwn",
              text: text,
            },
          },
          {
            type: "actions",
            elements: [
              {
                type: "button",
                text: {
                  type: "plain_text",
                  text: "è³¼å…¥å®Œäº†",
                },
                style: "primary",
                action_id: "purchase_complete",
                value: JSON.stringify({
                  applicant_id: applicantId,
                }),
              },
            ],
          },
        ],
      }),
    });

    const result = await response.json();

    if (!result.ok) {
      console.error("è³¼å…¥å®Œäº†ä¾é ¼æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", result.error);
    }

    return result.ok;
  } catch (error) {
    console.error("è³¼å…¥å®Œäº†ä¾é ¼æŠ•ç¨¿ä¾‹å¤–:", error);
    return false;
  }
}

/**
 * é‡‘é¡ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
 */
function validateAmount(amount: string): { valid: boolean; error?: string } {
  // ç©ºæ–‡å­—ãƒã‚§ãƒƒã‚¯
  if (!amount || amount.trim() === "") {
    return { valid: false, error: "é‡‘é¡ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" };
  }

  // ã‚«ãƒ³ãƒã‚’é™¤å»
  const cleanedAmount = amount.replace(/,/g, "");

  // æ•°å€¤ãƒã‚§ãƒƒã‚¯
  if (!/^\d+$/.test(cleanedAmount)) {
    return { valid: false, error: "é‡‘é¡ã¯æ•´æ•°ã§å…¥åŠ›ã—ã¦ãã ã•ã„" };
  }

  // æ•´æ•°å¤‰æ›ãƒã‚§ãƒƒã‚¯
  const numAmount = parseInt(cleanedAmount);
  if (isNaN(numAmount)) {
    return { valid: false, error: "é‡‘é¡ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“" };
  }

  // ç¯„å›²ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
  if (numAmount <= 0) {
    return { valid: false, error: "é‡‘é¡ã¯0ã‚ˆã‚Šå¤§ãã„å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" };
  }

  return { valid: true };
}

/**
 * ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã®å‡¦ç†
 */
async function handleSlashCommand(formData: URLSearchParams): Promise<Response> {
  const channelId = formData.get("channel_id");
  const userId = formData.get("user_id");
  const userName = formData.get("user_name");
  const command = formData.get("command");
  const triggerId = formData.get("trigger_id");

  // ãƒãƒ£ãƒ³ãƒãƒ«åˆ¶é™ã®ãƒã‚§ãƒƒã‚¯
  const channelCheckResponse = checkChannelAndRespond(channelId || "", "è³¼è²·ç”³è«‹");
  if (channelCheckResponse) {
    return channelCheckResponse;
  }

  // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
  if (!triggerId) {
    return new Response(
      JSON.stringify({
        response_type: "ephemeral",
        text: "âŒ trigger_idãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚",
      }),
      {
        headers: { "Content-Type": "application/json" },
        status: 200,
      }
    );
  }

  const result = await openModal(triggerId, channelId || "");

  if (result.success) {
    return new Response(null, { status: 200 });
  } else {
    const errorMessage = result.error === "invalid_trigger"
      ? "âŒ ã‚³ãƒãƒ³ãƒ‰ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚Œã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ `/è³¼è²·ç”³è«‹` ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚"
      : result.error === "not_authed" || result.error === "invalid_auth"
        ? "âŒ Bot Tokenã®èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚"
        : `âŒ ãƒ•ã‚©ãƒ¼ãƒ ã®è¡¨ç¤ºã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¨ãƒ©ãƒ¼: ${result.error || "ä¸æ˜"}`;

    return new Response(
      JSON.stringify({
        response_type: "ephemeral",
        text: errorMessage,
      }),
      {
        headers: { "Content-Type": "application/json" },
        status: 200,
      }
    );
  }
}

/**
 * ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã®å‡¦ç†
 */
async function handleInteractivity(payload: any): Promise<Response> {
  const type = payload.type;

  if (type === "view_submission") {
    // ãƒ¢ãƒ¼ãƒ€ãƒ«é€ä¿¡å‡¦ç†
    const values = payload.view.state.values;

    const itemName = values.item_name_block.item_name.value;
    const amount = values.amount_block.amount.value;
    const url = values.url_block.url.value;
    const purpose = values.purpose_block.purpose.value || "";

    // é‡‘é¡ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    const validation = validateAmount(amount);
    if (!validation.valid) {
      return new Response(
        JSON.stringify({
          response_action: "errors",
          errors: {
            amount_block: validation.error,
          },
        }),
        {
          headers: { "Content-Type": "application/json" },
          status: 200,
        }
      );
    }

    // private_metadataã‹ã‚‰ãƒãƒ£ãƒ³ãƒãƒ«æƒ…å ±ã‚’å–å¾—
    const metadata = payload.view.private_metadata
      ? JSON.parse(payload.view.private_metadata)
      : null;

    // å…ˆã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™ï¼ˆSlackã¯3ç§’ä»¥å†…ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒå¿…è¦ï¼‰
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã¯éåŒæœŸã§å®Ÿè¡Œ
    if (metadata && metadata.channel) {
      // éåŒæœŸã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿ï¼ˆawaitã—ãªã„ï¼‰
      postMessage(
        metadata.channel,
        itemName,
        amount,
        url,
        purpose,
        payload.user.id
      ).then(async result => {
        if (result.success && result.ts) {
          // Notionã«ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚SlackæŠ•ç¨¿ã¯ç¶™ç¶šï¼‰
          if (NOTION_ENABLED) {
            const applicantName = await getSlackUserName(payload.user.id);
            const applicationDate = new Date();
            const cleanedAmount = amount.replace(/,/g, "");
            const numAmount = parseInt(cleanedAmount);

            addToNotionDatabase(
              applicantName,
              applicationDate,
              itemName,
              numAmount,
              url,
              purpose,
              metadata.channel,
              result.ts
            ).catch(error => {
              console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆã‚¨ãƒ©ãƒ¼ï¼ˆéåŒæœŸï¼‰:", error);
            });
          }

          // æ‰¿èªä¾é ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
          return postApprovalRequest(metadata.channel, result.ts, payload.user.id);
        }
      }).catch(error => {
        console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
      });
    } else {
      console.error("ãƒãƒ£ãƒ³ãƒãƒ«æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    }

    // å³åº§ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
    return new Response(null, { status: 200 });
  }

  if (type === "block_actions") {
    // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
    const action = payload.actions[0];
    const userId = payload.user.id;

    if (action.action_id === "approve_first") {
      // æ‰¿èªãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸ
      const value = JSON.parse(action.value);
      const approvers = value.approvers;
      const approved = value.approved || false;
      const approvedBy = value.approvedBy || null;
      const applicantId = value.applicant_id;

      const channel = payload.channel.id;
      const threadTs = payload.message.thread_ts || payload.message.ts;

      // æ—¢ã«æ‰¿èªæ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
      if (approved) {
        // æ—¢ã«æ‰¿èªæ¸ˆã¿ã®å ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: `âŒ <@${userId}> ã•ã‚“ã€æ—¢ã« <@${approvedBy}> ãŒæ‰¿èªæ¸ˆã¿ã§ã™ã€‚`,
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ‰¿èªè€…ã‹ãƒã‚§ãƒƒã‚¯
      if (!approvers.includes(userId)) {
        // æ‰¿èªè€…ä»¥å¤–ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: "âŒ æ¨©é™ã‚’æŒã¤äººã ã‘ãŒæ‰¿èªãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚",
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // æ‰¿èªè€…ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã¾ãšãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰ã‚¹ãƒ¬ãƒƒãƒ‰ã«è¨˜éŒ²
      const messageTs = payload.message.ts;

      // å³åº§ã«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ï¼ˆchat.update APIã‚’ä½¿ç”¨ï¼‰
      await fetch("https://slack.com/api/chat.update", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
        },
        body: JSON.stringify({
          channel: channel,
          ts: messageTs,
          text: `ç”³è«‹è€…ãŒåå¤å±‹ã‚ªãƒ•ã‚£ã‚¹ãƒ¡ãƒ³ãƒãƒ¼ãªã‚‰ <@${FIRST_APPROVER_NAGOYA}> ãŒæ‰¿èªã—ã¦\nç”³è«‹è€…ãŒæ±äº¬ã‚ªãƒ•ã‚£ã‚¹ãƒ¡ãƒ³ãƒãƒ¼ãªã‚‰ <@${FIRST_APPROVER_TOKYO}> ãŒæ‰¿èªã—ã¦`,
          blocks: [
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `ç”³è«‹è€…ãŒåå¤å±‹ã‚ªãƒ•ã‚£ã‚¹ãƒ¡ãƒ³ãƒãƒ¼ãªã‚‰ <@${FIRST_APPROVER_NAGOYA}> ãŒæ‰¿èªã—ã¦\n` +
                  `ç”³è«‹è€…ãŒæ±äº¬ã‚ªãƒ•ã‚£ã‚¹ãƒ¡ãƒ³ãƒãƒ¼ãªã‚‰ <@${FIRST_APPROVER_TOKYO}> ãŒæ‰¿èªã—ã¦`,
              },
            },
          ],
        }),
      });

      // ã‚¹ãƒ¬ãƒƒãƒ‰ã«æ‰¿èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
      Promise.all([
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: `âœ… <@${userId}> ãŒä¸€æ¬¡æ‰¿èªã—ã¾ã—ãŸ`,
          }),
        }),
      ]).then(async () => {
        // Notionãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒ•ãƒ­ãƒ¼ç¶™ç¶šï¼‰
        if (NOTION_ENABLED) {
          const pageId = await findNotionRecordByThreadTs(channel, threadTs);
          if (pageId) {
            const approverName = await getSlackUserName(userId);
            const approvalDate = new Date();
            await updateNotionRecordFirstApproval(pageId, approverName, approvalDate).catch(error => {
              console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆä¸€æ¬¡æ‰¿èªã€éåŒæœŸï¼‰:", error);
            });
          }
        }

        // äºŒæ¬¡æ‰¿èªä¾é ¼ã‚’æŠ•ç¨¿
        return postSecondApprovalRequest(channel, threadTs, applicantId);
      }).catch(error => {
        console.error("æ‰¿èªè¨˜éŒ²æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
      });

      // å³åº§ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
      return new Response(null, { status: 200 });
    }

    if (action.action_id === "approve_second") {
      // äºŒæ¬¡æ‰¿èªãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸ
      const value = JSON.parse(action.value);
      const approver = value.approver;
      const approved = value.approved || false;
      const approvedBy = value.approvedBy || null;
      const applicantId = value.applicant_id;

      const channel = payload.channel.id;
      const threadTs = payload.message.thread_ts || payload.message.ts;

      // æ—¢ã«æ‰¿èªæ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
      if (approved) {
        // æ—¢ã«æ‰¿èªæ¸ˆã¿ã®å ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: `âŒ <@${userId}> ã•ã‚“ã€æ—¢ã« <@${approvedBy}> ãŒæœ€çµ‚æ‰¿èªæ¸ˆã¿ã§ã™ã€‚`,
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒäºŒæ¬¡æ‰¿èªè€…ã‹ãƒã‚§ãƒƒã‚¯
      if (userId !== approver) {
        // æ‰¿èªè€…ä»¥å¤–ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: "âŒ æ¨©é™ã‚’æŒã¤äººã ã‘ãŒæ‰¿èªãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚",
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // æ‰¿èªè€…ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã¾ãšãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰ã‚¹ãƒ¬ãƒƒãƒ‰ã«è¨˜éŒ²
      const messageTs2 = payload.message.ts;

      // å³åº§ã«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ï¼ˆchat.update APIã‚’ä½¿ç”¨ï¼‰
      await fetch("https://slack.com/api/chat.update", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
        },
        body: JSON.stringify({
          channel: channel,
          ts: messageTs2,
          text: `æœ€çµ‚æ‰¿èªã‚’ãŠé¡˜ã„ã—ã¾ã™: <@${SECOND_APPROVER}>`,
          blocks: [
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `æœ€çµ‚æ‰¿èªã‚’ãŠé¡˜ã„ã—ã¾ã™: <@${SECOND_APPROVER}>`,
              },
            },
          ],
        }),
      });

      // ã‚¹ãƒ¬ãƒƒãƒ‰ã«æ‰¿èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
      fetch("https://slack.com/api/chat.postMessage", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
        },
        body: JSON.stringify({
          channel: channel,
          thread_ts: threadTs,
          text: `âœ… <@${userId}> ãŒæœ€çµ‚æ‰¿èªã—ã¾ã—ãŸã€‚`,
        }),
      }).then(async () => {
        // Notionãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒ•ãƒ­ãƒ¼ç¶™ç¶šï¼‰
        if (NOTION_ENABLED) {
          const pageId = await findNotionRecordByThreadTs(channel, threadTs);
          if (pageId) {
            const approverName = await getSlackUserName(userId);
            const approvalDate = new Date();
            await updateNotionRecordFinalApproval(pageId, approverName, approvalDate).catch(error => {
              console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆæœ€çµ‚æ‰¿èªã€éåŒæœŸï¼‰:", error);
            });
          }
        }

        // è³¼å…¥å®Œäº†ä¾é ¼ã‚’æŠ•ç¨¿
        return postPurchaseCompleteRequest(channel, threadTs, applicantId);
      }).catch(error => {
        console.error("æ‰¿èªè¨˜éŒ²æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
      });

      // å³åº§ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
      return new Response(null, { status: 200 });
    }

    if (action.action_id === "purchase_complete") {
      // è³¼å…¥å®Œäº†ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸ
      const value = JSON.parse(action.value);
      const completed = value.completed || false;
      const completedBy = value.completedBy || null;
      const applicantId = value.applicant_id;

      const channel = payload.channel.id;
      const threadTs = payload.message.thread_ts || payload.message.ts;

      // æ—¢ã«è³¼å…¥å®Œäº†æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
      if (completed) {
        // æ—¢ã«è³¼å…¥å®Œäº†æ¸ˆã¿ã®å ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: `âŒ <@${userId}> ã•ã‚“ã€æ—¢ã« <@${completedBy}> ãŒè³¼å…¥å®Œäº†æ¸ˆã¿ã§ã™ã€‚`,
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç”³è«‹è€…ã‹ãƒã‚§ãƒƒã‚¯
      if (userId !== applicantId) {
        // ç”³è«‹è€…ä»¥å¤–ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
        fetch("https://slack.com/api/chat.postMessage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
          },
          body: JSON.stringify({
            channel: channel,
            thread_ts: threadTs,
            text: "âŒ ç”³è«‹è€…ã®ã¿ãŒè³¼å…¥å®Œäº†ãƒœã‚¿ãƒ³ã‚’æŠ¼ã›ã¾ã™ã€‚",
          }),
        }).catch(error => {
          console.error("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
        });

        // å¤‰æ›´ãªã—
        return new Response(null, { status: 200 });
      }

      // ç”³è«‹è€…ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã€ã¾ãšãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰ã‚¹ãƒ¬ãƒƒãƒ‰ã«è¨˜éŒ²
      const messageTs3 = payload.message.ts;

      // å³åº§ã«ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ï¼ˆchat.update APIã‚’ä½¿ç”¨ï¼‰
      await fetch("https://slack.com/api/chat.update", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
        },
        body: JSON.stringify({
          channel: channel,
          ts: messageTs3,
          text: `è³¼å…¥ã—ãŸã‚‰è³¼å…¥å®Œäº†ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`,
          blocks: [
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `è³¼å…¥ã—ãŸã‚‰è³¼å…¥å®Œäº†ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚`,
              },
            },
          ],
        }),
      });

      // ã‚¹ãƒ¬ãƒƒãƒ‰ã«è³¼å…¥å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ•ç¨¿
      fetch("https://slack.com/api/chat.postMessage", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SLACK_BOT_TOKEN}`,
        },
        body: JSON.stringify({
          channel: channel,
          thread_ts: threadTs,
          text: `âœ… <@${userId}> ãŒè³¼å…¥å®Œäº†ã—ã¾ã—ãŸã€‚`,
        }),
      }).then(async () => {
        // Notionãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒ•ãƒ­ãƒ¼ç¶™ç¶šï¼‰
        if (NOTION_ENABLED) {
          const pageId = await findNotionRecordByThreadTs(channel, threadTs);
          if (pageId) {
            const purchaserName = await getSlackUserName(userId);
            const purchaseDate = new Date();
            await updateNotionRecordPurchaseComplete(pageId, purchaserName, purchaseDate).catch(error => {
              console.error("Notionãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼ï¼ˆè³¼å…¥å®Œäº†ã€éåŒæœŸï¼‰:", error);
            });
          }
        }
      }).catch(error => {
        console.error("è³¼å…¥å®Œäº†è¨˜éŒ²æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼:", error);
      });

      // å³åº§ã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
      return new Response(null, { status: 200 });
    }
  }

  return new Response(null, { status: 200 });
}

/**
 * ãƒ¡ã‚¤ãƒ³ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
 */
serve(async (req: Request) => {
  // CORSå¯¾å¿œ
  if (req.method === "OPTIONS") {
    return new Response(null, {
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, X-Slack-Request-Timestamp, X-Slack-Signature",
      },
    });
  }

  // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
  if (req.method === "GET") {
    return new Response(JSON.stringify({ status: "ok" }), {
      headers: { "Content-Type": "application/json" },
      status: 200,
    });
  }

  // POSTä»¥å¤–ã¯æ‹’å¦
  if (req.method !== "POST") {
    return new Response(JSON.stringify({ error: "Method not allowed" }), {
      headers: { "Content-Type": "application/json" },
      status: 405,
    });
  }

  try {
    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æ¤œè¨¼
    const timestamp = req.headers.get("X-Slack-Request-Timestamp");
    const signature = req.headers.get("X-Slack-Signature");

    if (!timestamp || !signature) {
      return new Response(JSON.stringify({ error: "ä¸æ­£ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ" }), {
        headers: { "Content-Type": "application/json" },
        status: 400,
      });
    }

    const body = await req.text();

    // ç½²åæ¤œè¨¼
    const isValid = await verifySlackSignature(body, timestamp, signature, SLACK_SIGNING_SECRET);
    if (!isValid) {
      return new Response(JSON.stringify({ error: "ç½²åæ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ" }), {
        headers: { "Content-Type": "application/json" },
        status: 401,
      });
    }

    // Content-Typeã‚’ç¢ºèªã—ã¦ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¿ã‚¤ãƒ—ã‚’åˆ¤åˆ¥
    const contentType = req.headers.get("Content-Type");

    if (contentType?.includes("application/x-www-form-urlencoded")) {
      const formData = new URLSearchParams(body);

      // payloadãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£
      if (formData.has("payload")) {
        const payload = JSON.parse(formData.get("payload")!);
        return await handleInteractivity(payload);
      }

      // ãã‚Œä»¥å¤–ã¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰
      return await handleSlashCommand(formData);
    }

    return new Response(JSON.stringify({ error: "ä¸æ­£ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆå½¢å¼" }), {
      headers: { "Content-Type": "application/json" },
      status: 400,
    });
  } catch (error) {
    console.error("ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ:", error);
    return new Response(
      JSON.stringify({
        response_type: "ephemeral",
        text: "âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚",
      }),
      {
        headers: { "Content-Type": "application/json" },
        status: 500,
      }
    );
  }
});
