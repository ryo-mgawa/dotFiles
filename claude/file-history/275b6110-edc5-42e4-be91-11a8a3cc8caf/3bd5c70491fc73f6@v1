import { UserContextTypes } from '@app/requestContext';
import { Test, TestingModule } from '@nestjs/testing';
import { GetApplicationsUseCase } from '../../../../application/getApplicationsUseCase';
import { ApplicationsController } from '../applicationsController';

describe('ApplicationsController', () => {
  let controller: ApplicationsController;
  let useCase: GetApplicationsUseCase;

  const mockUser: UserContextTypes = {
    userId: 'test-user-id',
    organizationId: 'test-org-id',
    role: 'ARRIVAL_MANAGER',
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ApplicationsController],
      providers: [
        {
          provide: GetApplicationsUseCase,
          useValue: {
            execute: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<ApplicationsController>(ApplicationsController);
    useCase = module.get<GetApplicationsUseCase>(GetApplicationsUseCase);
  });

  it('コントローラーが正しく定義される', () => {
    expect(controller).toBeDefined();
  });

  it('コンストラクタが正しくuseCaseを注入する', () => {
    const testUseCase = {
      execute: jest.fn(),
    } as any;
    const testController = new ApplicationsController(testUseCase);

    expect(testController).toBeDefined();
    expect(testController['getApplicationsUseCase']).toBe(testUseCase);
  });

  describe('getApplications', () => {
    it('useCase.executeが正しいorganizationIdで呼び出される', async () => {
      await controller.getApplications(mockUser);

      expect(useCase.execute).toHaveBeenCalledWith('test-org-id');
      expect(useCase.execute).toHaveBeenCalledTimes(1);
    });

    it('異なるorganizationIdの場合、正しく渡される', async () => {
      const mockResponse = {} as Response;
      const differentUser: UserContextTypes = {
        userId: 'other-user-id',
        organizationId: 'other-org-id',
        role: 'ARRIVAL_MANAGER',
      };

      await controller.getApplications(differentUser, mockResponse);

      expect(useCase.execute).toHaveBeenCalledWith('other-org-id');
    });

    it('複数回呼び出された場合、それぞれ正しく処理される', async () => {
      const mockResponse = {} as Response;
      const user1: UserContextTypes = {
        userId: 'user-1',
        organizationId: 'org-1',
        role: 'ARRIVAL_MANAGER',
      };
      const user2: UserContextTypes = {
        userId: 'user-2',
        organizationId: 'org-2',
        role: 'ARRIVAL_MANAGER',
      };

      await controller.getApplications(user1, mockResponse);
      await controller.getApplications(user2, mockResponse);

      expect(useCase.execute).toHaveBeenCalledTimes(2);
      expect(useCase.execute).toHaveBeenNthCalledWith(1, 'org-1');
      expect(useCase.execute).toHaveBeenNthCalledWith(2, 'org-2');
    });

    it('useCase.executeがエラーをスローした場合、エラーが伝播される', async () => {
      const mockResponse = {} as Response;
      const error = new Error('Test error');

      jest.spyOn(useCase, 'execute').mockRejectedValue(error);

      await expect(
        controller.getApplications(mockUser, mockResponse)
      ).rejects.toThrow('Test error');
      expect(useCase.execute).toHaveBeenCalledWith('test-org-id');
    });

    it('useCase.executeがFirestoreエラーをスローした場合、エラーが伝播される', async () => {
      const mockResponse = {} as Response;
      const error = new Error('Firestore connection error');

      jest.spyOn(useCase, 'execute').mockRejectedValue(error);

      await expect(
        controller.getApplications(mockUser, mockResponse)
      ).rejects.toThrow('Firestore connection error');
    });

    it('戻り値がvoidであることを確認', async () => {
      const mockResponse = {} as Response;

      const result = await controller.getApplications(mockUser, mockResponse);

      expect(result).toBeUndefined();
    });

    it('userContextにorganizationIdが存在しない場合でも呼び出される', async () => {
      const mockResponse = {} as Response;
      const userWithoutOrgId: UserContextTypes = {
        userId: 'test-user-id',
        organizationId: undefined as any,
        role: 'ARRIVAL_MANAGER',
      };

      await controller.getApplications(userWithoutOrgId, mockResponse);

      expect(useCase.execute).toHaveBeenCalledWith(undefined);
    });
  });
});
