import { Logger } from '@app/logger';
import { ProviderIdentity } from '@app/rdb';
import { Inject, Injectable } from '@nestjs/common';
import { Knex } from 'knex';
import { ShipmentConflictException } from '../../exception/shipmentConflictException';
import { ShipmentSaveException } from '../../exception/shipmentSaveException';
import { SaveShipment } from './types/saveShipment';

const POSTGRES_UNIQUE_VIOLATION = '23505';

@Injectable()
export class ShipmentDAO {
  constructor(@Inject(ProviderIdentity) private rdb: Knex) { }

  public async save(shipments: SaveShipment[]): Promise<void> {
    if (shipments.length === 0) {
      return;
    }

    const records = shipments.map((shipment) => ({
      id: shipment.id,
      organization_id: shipment.organizationId,
      slip_id: shipment.slipId,
      consignor: JSON.stringify(shipment.consignor),
      consignee: JSON.stringify(shipment.consignee),
      origin_spot_id: shipment.originSpotId,
      destination_spot_id: shipment.destinationSpotId,
      meta: shipment.meta ? JSON.stringify(shipment.meta) : null,
    }));

    try {
      await this.rdb.transaction(async (trx) => {
        await trx('shipment').insert(records);
      });
    } catch (error: any) {
      Logger.error(error);

      if (error.code !== POSTGRES_UNIQUE_VIOLATION) {
        throw new ShipmentSaveException('シップメント情報の保存に失敗しました。');
      }

      const constraintName = error.constraint || '';

      if (constraintName.includes('pkey') || constraintName.includes('_id_')) {
        throw new ShipmentConflictException('指定されたIDは既に存在します。');
      }

      if (constraintName.includes('slip_id') && constraintName.includes('organization_id')) {
        throw new ShipmentConflictException('指定された伝票IDと組織IDの組み合わせは既に存在します。');
      }

      throw new ShipmentConflictException('シップメント情報が既に存在します。');
    }
  }
}
