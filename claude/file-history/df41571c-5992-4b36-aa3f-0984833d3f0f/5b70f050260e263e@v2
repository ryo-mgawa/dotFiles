import { Test, TestingModule } from '@nestjs/testing';
import { Response } from 'express';
import { AddShipmentEventsPresenter } from '../addShipmentEventsPresenter';

describe('AddShipmentEventsPresenter', () => {
  let presenter: AddShipmentEventsPresenter;
  let mockResponse: Partial<Response>;

  beforeEach(async () => {
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AddShipmentEventsPresenter,
        {
          provide: 'RESPONSE',
          useValue: mockResponse,
        },
      ],
    }).compile();

    presenter = module.get<AddShipmentEventsPresenter>(AddShipmentEventsPresenter);
  });

  it('presenterが正しく定義される', () => {
    expect(presenter).toBeDefined();
  });

  it('コンストラクタが正しくresponseを注入する', () => {
    const testResponse: Partial<Response> = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };
    const testPresenter = new AddShipmentEventsPresenter(testResponse as Response);

    expect(testPresenter).toBeDefined();
    expect(testPresenter['response']).toBe(testResponse);
  });

  it('DIコンテナを通じてRESPONSEトークンからresponseが注入される', () => {
    expect(presenter).toBeDefined();
    expect(presenter['response']).toBe(mockResponse);
  });

  describe('output', () => {
    it('ステータス201で正しいレスポンスを返す', () => {
      presenter.output();

      expect(mockResponse.status).toHaveBeenCalledWith(201);
      expect(mockResponse.send).toHaveBeenCalledWith({
        status: 'success',
      });
    });

    it('statusとsendが正しい順序で呼び出される', () => {
      presenter.output();

      expect(mockResponse.status).toHaveBeenCalledTimes(1);
      expect(mockResponse.send).toHaveBeenCalledTimes(1);
    });

    it('複数回呼び出しても正しく動作する', () => {
      presenter.output();
      presenter.output();

      expect(mockResponse.status).toHaveBeenCalledTimes(2);
      expect(mockResponse.send).toHaveBeenCalledTimes(2);
      expect(mockResponse.status).toHaveBeenCalledWith(201);
      expect(mockResponse.send).toHaveBeenLastCalledWith({
        status: 'success',
      });
    });
  });
});
