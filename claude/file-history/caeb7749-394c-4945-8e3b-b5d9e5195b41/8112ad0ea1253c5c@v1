import { INestApplication } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';
import { ApplicationsPresenterProviderIdentity } from '../../interface/presenter/applicationsPresenter';
import { GetApplicationsService } from '../service/getApplicationsService';
import { GetApplicationsUseCase } from '../getApplicationsUseCase';

describe('GetApplicationsUseCase', () => {
  let getApplicationsUseCase: GetApplicationsUseCase;
  let moduleRef: TestingModule;
  let app: INestApplication;
  let mockService: { execute: jest.Mock };
  let mockPresenter: { output: jest.Mock };

  describe('execute', () => {
    it('アプリケーションが0件の場合、空配列をPresenterに渡す', async () => {
      await createTestingModule([]);

      await getApplicationsUseCase.execute('org-123');

      expect(mockService.execute).toHaveBeenCalledWith('org-123');
      expect(mockPresenter.output).toHaveBeenCalledWith([]);
    });

    it('アプリケーションが1件の場合、正しくPresenterに渡す', async () => {
      const applications = [
        {
          id: 'app-1',
          name: 'アプリケーション1',
        },
      ];
      await createTestingModule(applications);

      await getApplicationsUseCase.execute('org-123');

      expect(mockService.execute).toHaveBeenCalledWith('org-123');
      expect(mockPresenter.output).toHaveBeenCalledWith(applications);
    });

    it('アプリケーションが複数件の場合、正しくPresenterに渡す', async () => {
      const applications = [
        {
          id: 'app-1',
          name: 'アプリケーション1',
        },
        {
          id: 'app-2',
          name: 'アプリケーション2',
        },
        {
          id: 'app-3',
          name: 'アプリケーション3',
        },
      ];
      await createTestingModule(applications);

      await getApplicationsUseCase.execute('org-123');

      expect(mockService.execute).toHaveBeenCalledWith('org-123');
      expect(mockPresenter.output).toHaveBeenCalledWith(applications);
    });

    it('異なる組織IDで呼び出された場合、正しく処理される', async () => {
      const applications = [
        {
          id: 'app-1',
          name: 'アプリケーション1',
        },
      ];
      await createTestingModule(applications);

      await getApplicationsUseCase.execute('org-456');

      expect(mockService.execute).toHaveBeenCalledWith('org-456');
      expect(mockPresenter.output).toHaveBeenCalledWith(applications);
    });

    it('Serviceが例外をスローした場合、例外が伝播される', async () => {
      const error = new Error('Firestore error');
      await createTestingModule([], error);

      await expect(getApplicationsUseCase.execute('org-123')).rejects.toThrow(
        'Firestore error'
      );
      expect(mockService.execute).toHaveBeenCalledWith('org-123');
      expect(mockPresenter.output).not.toHaveBeenCalled();
    });

    it('複数回呼び出された場合、それぞれ正しく処理される', async () => {
      const applications1 = [
        {
          id: 'app-1',
          name: 'アプリケーション1',
        },
      ];
      const applications2 = [
        {
          id: 'app-2',
          name: 'アプリケーション2',
        },
        {
          id: 'app-3',
          name: 'アプリケーション3',
        },
      ];
      await createTestingModule([]);

      mockService.execute.mockResolvedValueOnce(applications1);
      mockService.execute.mockResolvedValueOnce(applications2);

      await getApplicationsUseCase.execute('org-123');
      await getApplicationsUseCase.execute('org-456');

      expect(mockService.execute).toHaveBeenCalledTimes(2);
      expect(mockService.execute).toHaveBeenNthCalledWith(1, 'org-123');
      expect(mockService.execute).toHaveBeenNthCalledWith(2, 'org-456');
      expect(mockPresenter.output).toHaveBeenCalledTimes(2);
      expect(mockPresenter.output).toHaveBeenNthCalledWith(1, applications1);
      expect(mockPresenter.output).toHaveBeenNthCalledWith(2, applications2);
    });
  });

  const createTestingModule = async (
    applications: { id: string; name: string }[],
    error?: Error
  ) => {
    mockService = {
      execute: error
        ? jest.fn().mockRejectedValue(error)
        : jest.fn().mockResolvedValue(applications),
    };

    mockPresenter = {
      output: jest.fn(),
    };

    moduleRef = await Test.createTestingModule({
      imports: [],
      providers: [
        GetApplicationsUseCase,
        {
          provide: GetApplicationsService,
          useValue: mockService,
        },
        {
          provide: ApplicationsPresenterProviderIdentity,
          useValue: mockPresenter,
        },
      ],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();

    getApplicationsUseCase = moduleRef.get<GetApplicationsUseCase>(
      GetApplicationsUseCase
    );
  };

  afterEach(async () => {
    if (app) {
      await app.close();
    }
    if (moduleRef) {
      await moduleRef.close();
    }
  });
});
