# Automation Applications API - データフロー詳細説明

## 概要

このドキュメントでは、`GET /api/manager/private/automation/applications` エンドポイントの実装について、データの流れを詳細に説明します。

## アーキテクチャパターン

本実装はClean Architectureパターンに従っており、以下の層構造になっています：

```
Controller層 (Presentation)
    ↓
UseCase層 (Application)
    ↓
Service層 (Application)
    ↓
Firestore (Infrastructure)
    ↓
Presenter層 (Presentation)
    ↓
Response
```

## エンドポイント情報

- **URL**: `/api/manager/private/automation/applications`
- **Method**: `GET`
- **認証**: Firebase JWT (ARRIVAL_MANAGER ロール必須)
- **レスポンス形式**:
```json
{
  "status": "success",
  "applications": [
    {
      "id": "application-id-1",
      "name": "アプリケーション名1"
    },
    {
      "id": "application-id-2",
      "name": "アプリケーション名2"
    }
  ]
}
```

## Firestoreデータ構造

このAPIは、Firestoreの名前付きデータベース `automation` から以下の2つのコレクションにアクセスします：

### organizations コレクション
```
organizations/{organizationId}
  └─ applications: string[]  // アプリケーションIDの配列
```

### applications コレクション
```
applications/{applicationId}
  └─ name: string  // アプリケーション名
```

### データ取得の流れ
1. `organizations/{organizationId}` から該当組織のアプリケーションID一覧を取得
2. 取得したIDを使って `applications` コレクションから各アプリケーションの詳細情報を取得

## 詳細なデータフロー

### 1. リクエスト受信 (Controller層)

**ファイル**: `server/apps/joint/src/presentation/manager/controller/applicationsController.ts`

```typescript
@Roles(Role.ARRIVAL_MANAGER)
@Controller('/private/automation')
export class ApplicationsController {
  @Get('/applications')
  public async getApplications(
    @User() user: UserContextTypes,
    @Response() _,
  ): Promise<void> {
    await this.getApplicationsUseCase.execute(user.organizationId);
  }
}
```

**処理内容**:
- HTTPリクエストを受信
- `@Roles(Role.ARRIVAL_MANAGER)` デコレータで認証・認可チェック
- `@User()` デコレータからJWTトークンの情報を取得し、`organizationId` を抽出
- `GetApplicationsUseCase.execute()` を呼び出し、organizationIdを渡す
- `@Response()` パラメータにより、Expressの `Response` オブジェクトがDIコンテナに登録される

### 2. ビジネスロジック実行 (UseCase層)

**ファイル**: `server/apps/joint/src/application/getApplicationsUseCase.ts`

```typescript
@Injectable()
export class GetApplicationsUseCase {
  constructor(
    private readonly getApplicationsService: GetApplicationsService,
    @Inject(ApplicationsPresenterProviderIdentity)
    private readonly presenter: ApplicationsPresenterInterface,
  ) {}

  public async execute(organizationId: string): Promise<void> {
    const applications = await this.getApplicationsService.execute(organizationId);
    this.presenter.output(applications);
  }
}
```

**処理内容**:
- `GetApplicationsService` を使ってFirestoreからデータを取得
- 取得した `Application[]` を `ApplicationsPresenter` に渡す
- Presenterはインターフェース（`ApplicationsPresenterInterface`）として注入されるため、テスト時にモック化が容易

**依存性注入のポイント**:
- `GetApplicationsService` は通常のクラスとして注入
- `ApplicationsPresenterInterface` はシンボル（`ApplicationsPresenterProviderIdentity`）を使って注入
  - これにより、Interface層とPresentation層の依存関係を逆転させている（Dependency Inversion）

### 3. データ取得 (Service層)

**ファイル**: `server/apps/joint/src/application/service/getApplicationsService.ts`

```typescript
@Injectable()
export class GetApplicationsService {
  constructor(
    @Inject(AutomationFirestoreProviderIdentity)
    private readonly firestore: Firestore,
  ) {}

  public async execute(organizationId: string): Promise<Application[]> {
    // 1. 組織のアプリケーションID一覧を取得
    const applicationIds = await this.getApplicationIds(organizationId);

    if (applicationIds.length === 0) {
      return [];
    }

    // 2. アプリケーション詳細を取得
    return this.getApplicationDetails(applicationIds);
  }
}
```

#### 3-1. 組織のアプリケーションID一覧取得

```typescript
private async getApplicationIds(organizationId: string): Promise<string[]> {
  const orgDoc = await this.firestore
    .collection(ORGANIZATIONS_COLLECTION)  // 'organizations'
    .doc(organizationId)
    .get();

  if (!orgDoc.exists) {
    return [];
  }

  return orgDoc.data()?.applications || [];
}
```

**処理内容**:
- Firestoreの `organizations/{organizationId}` ドキュメントを取得
- ドキュメントが存在しない場合は空配列を返す
- `applications` フィールド（配列）を取得
  - 例: `['app-id-1', 'app-id-2', 'app-id-3']`

#### 3-2. アプリケーション詳細取得（チャンキング処理）

```typescript
private async getApplicationDetails(applicationIds: string[]): Promise<Application[]> {
  // IDを10個ずつのチャンクに分割
  const chunks = this.chunkArray(applicationIds, MAX_WHERE_IN_SIZE);

  // 各チャンクに対して並列でFirestoreクエリを実行
  const results = await Promise.all(
    chunks.map(chunk =>
      this.firestore
        .collection(APPLICATIONS_COLLECTION)  // 'applications'
        .where(FieldPath.documentId(), 'in', chunk)
        .get()
    )
  );

  // 結果を統合してApplication型に変換
  return results
    .flatMap(snapshot => snapshot.docs)
    .map(doc => ({
      id: doc.id,
      name: doc.data().name,
    }));
}
```

**処理内容**:
1. **チャンキング**: `applicationIds` を10個ずつのチャンクに分割
   - Firestoreの `in` クエリは最大10個までしか指定できない制約があるため
   - 例: `['id1', 'id2', ..., 'id25']` → `[['id1'...'id10'], ['id11'...'id20'], ['id21'...'id25']]`

2. **並列クエリ実行**: `Promise.all()` で各チャンクのクエリを並列実行
   - チャンク1: `WHERE __name__ IN ('id1', ..., 'id10')`
   - チャンク2: `WHERE __name__ IN ('id11', ..., 'id20')`
   - チャンク3: `WHERE __name__ IN ('id21', ..., 'id25')`

3. **結果の統合**:
   - `flatMap()` で各クエリ結果のドキュメント配列を1つの配列に統合
   - `map()` で各ドキュメントを `Application` 型に変換

**チャンク分割処理**:
```typescript
private chunkArray<T>(array: T[], size: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}
```

### 4. Firestoreアクセス (Infrastructure層)

**ファイル**: `server/libs/firebase/src/factories/automationFirestoreFactory/automationFirestoreFactory.ts`

```typescript
export const AutomationFirestoreFactory = {
  provide: AutomationFirestoreProviderIdentity,
  useFactory(configService: ConfigService): Firestore {
    const app = createFirebaseAdminApp({
      appName: FIREBASE_APP_NAME.FIREBASE_ADMIN_CLIENT_APP,
      initializeOptions: {
        serviceAccountId: configService.get('FIREBASE_TOKEN_ADMIN_SERVICE_ACCOUNT'),
      },
    });
    return getFirestore(app, AUTOMATION_DATABASE_NAME);  // 'automation'
  },
  inject: [ConfigService],
};
```

**処理内容**:
- Firebase Admin SDKを使用してFirebaseアプリを初期化
- `getFirestore(app, 'automation')` で名前付きデータベース `automation` に接続
- このFactoryで生成された `Firestore` インスタンスが `GetApplicationsService` に注入される

**名前付きデータベースについて**:
- デフォルトのFirestoreデータベースではなく、`automation` という名前の専用データベースを使用
- Terraformで定義: `infra/terraform/modules/automation/`
- 他のデータベースと論理的に分離されている

### 5. レスポンス生成 (Presenter層)

**ファイル**: `server/apps/joint/src/presentation/manager/presenter/applicationsPresenter.ts`

```typescript
@Injectable()
export class ApplicationsPresenter implements ApplicationsPresenterInterface {
  constructor(@Inject('RESPONSE') private readonly response: Response) {}

  public output(applications: Application[]): void {
    const output: GetApplicationsOutput = {
      status: 'success',
      applications,
    };
    this.response.status(200).json(output);
  }
}
```

**処理内容**:
- `UseCase` から受け取った `Application[]` を `GetApplicationsOutput` 型に変換
- Expressの `Response` オブジェクトを使ってJSONレスポンスを返す
- HTTPステータスコード 200 を設定

**型定義**:
```typescript
// Application型
export type Application = {
  id: string;
  name: string;
};

// GetApplicationsOutput型
export type GetApplicationsOutput = {
  status: 'success';
  applications: Application[];
};
```

## 依存性注入の仕組み

NestJSのDIコンテナにより、各層のコンポーネントが自動的に接続されます。

### Module構成

#### BaseJointModule

**ファイル**: `server/apps/joint/src/presentation/baseModule.ts`

```typescript
@Module({
  imports: [
    ConfigModule.forRoot(),
    FirebaseAdminModule,  // AutomationFirestoreFactoryを提供
    JwtModule.register({ ... }),
  ],
  providers: [
    GenerateJointTokenService,
    GetApplicationsService,  // 追加
    {
      provide: 'RESPONSE',
      useFactory: (request: Request) => request.res,
      inject: [REQUEST],
    },
  ],
  exports: ['RESPONSE', GenerateJointTokenService, GetApplicationsService],
})
export class BaseJointModule {}
```

**役割**:
- 基本的なサービスとインフラストラクチャの依存関係を提供
- `FirebaseAdminModule` をインポートすることで、`AutomationFirestoreFactory` が利用可能になる
- `GetApplicationsService` をプロバイダーとしてエクスポート

#### ManagerJointModule

**ファイル**: `server/apps/joint/src/presentation/manager/module.ts`

```typescript
@Module({
  imports: [BaseJointModule],
  controllers: [
    JointTokenController,
    ApplicationsController,  // 追加
  ],
  providers: [
    GenerateJointTokenUseCase,
    GetApplicationsUseCase,  // 追加
    {
      provide: ProviderIdentity,
      useClass: JointTokenPresenter,
    },
    {
      provide: ApplicationsPresenterProviderIdentity,  // 追加
      useClass: ApplicationsPresenter,
    },
  ],
  exports: [ProviderIdentity, ApplicationsPresenterProviderIdentity],
})
export class ManagerJointModule {}
```

**役割**:
- Manager向けのコントローラー、UseCase、Presenterを提供
- `BaseJointModule` から基本的なサービスをインポート
- シンボルベースの依存性注入により、InterfaceとPresenterを接続

#### FirebaseAdminModule

**ファイル**: `server/libs/firebase/src/module.ts`

```typescript
@Module({
  providers: [
    // ... 他のFactories
    AutomationFirestoreFactory,  // 追加
  ],
  exports: [
    // ... 他のProviderIdentities
    AutomationFirestoreProviderIdentity,  // 追加
  ],
})
export class FirebaseAdminModule {}
```

**役割**:
- `AutomationFirestoreFactory` を提供
- `AutomationFirestoreProviderIdentity` シンボルで `Firestore` インスタンスをエクスポート

### 依存関係の解決フロー

1. **アプリケーション起動時**:
   - NestJSがモジュールツリーをスキャン
   - 各モジュールのプロバイダーをDIコンテナに登録

2. **Firestore接続の確立**:
   - `FirebaseAdminModule` が `AutomationFirestoreFactory` を実行
   - `ConfigService` から環境変数を取得
   - Firebase Admin SDKで `automation` データベースに接続
   - 作成された `Firestore` インスタンスが `AutomationFirestoreProviderIdentity` シンボルに紐付けられる

3. **Serviceの初期化**:
   - `GetApplicationsService` のコンストラクタが実行される
   - `@Inject(AutomationFirestoreProviderIdentity)` により、DIコンテナから `Firestore` インスタンスが注入される

4. **UseCaseの初期化**:
   - `GetApplicationsUseCase` のコンストラクタが実行される
   - `GetApplicationsService` が通常の依存性として注入される
   - `@Inject(ApplicationsPresenterProviderIdentity)` により、`ApplicationsPresenter` が注入される

5. **リクエスト時**:
   - `ApplicationsController` が初期化され、`GetApplicationsUseCase` が注入される
   - リクエストスコープで `'RESPONSE'` トークンに `Response` オブジェクトが紐付けられる
   - `ApplicationsPresenter` に `Response` オブジェクトが注入される

## エラーハンドリング

### 組織が存在しない場合
- `getApplicationIds()` が空配列を返す
- `execute()` が空配列を返す
- レスポンス: `{ status: 'success', applications: [] }`

### アプリケーションIDが存在しない場合
- Firestoreの `whereIn` クエリは存在しないIDをスキップする
- 存在するアプリケーションのみが結果に含まれる
- レスポンス: 存在するアプリケーションのみの配列

### Firestoreエラー
- Firebase Admin SDKが例外をスロー
- NestJSのグローバル例外フィルターがキャッチ
- 適切なエラーレスポンスが返される

## パフォーマンス最適化

### 1. チャンキング処理
- Firestoreの `in` クエリ制限（最大10個）に対応
- 11個以上のアプリケーションIDがある場合でも正常に動作

### 2. 並列クエリ実行
- `Promise.all()` により複数のチャンクを並列で取得
- 例: 25個のIDがある場合、3つのクエリを並列実行（シーケンシャルに比べて約3倍高速）

### 3. 早期リターン
- アプリケーションIDが0個の場合、Firestoreクエリをスキップ

### 4. 名前付きデータベース
- `automation` データベースを使用することで、他のデータと物理的に分離
- インデックスの最適化やパフォーマンスチューニングが独立して実行可能

## テスタビリティ

### Interface層の分離
- `ApplicationsPresenterInterface` により、PresenterがUseCaseから疎結合
- テスト時にモックPresenterを注入可能

### Service層の単体テスト
- Firestoreインスタンスをモック化することで、外部依存なしでテスト可能
- チャンキング処理のロジックを独立してテスト可能

### UseCase層の単体テスト
- ServiceとPresenterの両方をモック化可能
- ビジネスロジックのみを純粋にテスト可能

## セキュリティ

### 認証・認可
- `@Roles(Role.ARRIVAL_MANAGER)` により、ARRIVAL_MANAGERロールを持つユーザーのみアクセス可能
- JWTトークンの検証は認証ガードで実行済み

### データアクセス制御
- ユーザーのJWTトークンから抽出された `organizationId` のみを使用
- 他の組織のデータにはアクセス不可

### 入力検証
- `organizationId` はJWTトークンから取得されるため、改ざん不可
- Firestoreのドキュメントパスとして安全に使用可能

## まとめ

このAPIは以下の特徴を持つ設計になっています：

1. **Clean Architecture**: 各層が明確に分離され、依存関係が一方向
2. **SOLID原則**: 特にDependency Inversionにより、テストと保守が容易
3. **スケーラビリティ**: チャンキング処理により、アプリケーション数に制限なし
4. **パフォーマンス**: 並列クエリ実行により、レスポンスタイムを最適化
5. **型安全性**: TypeScriptの型システムを活用し、実行時エラーを最小化
6. **セキュリティ**: ロールベースの認可とマルチテナント分離

## 関連ファイル一覧

### 新規作成ファイル
- `server/libs/firebase/src/factories/automationFirestoreFactory/providerIdentity.ts`
- `server/libs/firebase/src/factories/automationFirestoreFactory/automationFirestoreFactory.ts`
- `server/libs/firebase/src/factories/automationFirestoreFactory/index.ts`
- `server/apps/joint/src/interface/presenter/applicationsPresenter/providerIdentity.ts`
- `server/apps/joint/src/interface/presenter/applicationsPresenter/applicationsPresenterInterface.ts`
- `server/apps/joint/src/interface/presenter/applicationsPresenter/index.ts`
- `server/apps/joint/src/interface/presenter/types/getApplicationsOutput.ts`
- `server/apps/joint/src/application/service/getApplicationsService.ts`
- `server/apps/joint/src/application/getApplicationsUseCase.ts`
- `server/apps/joint/src/presentation/manager/presenter/applicationsPresenter.ts`
- `server/apps/joint/src/presentation/manager/controller/applicationsController.ts`

### 更新ファイル
- `server/libs/firebase/src/module.ts`
- `server/libs/firebase/src/index.ts`
- `server/apps/joint/src/presentation/baseModule.ts`
- `server/apps/joint/src/presentation/manager/module.ts`
