import { Firestore, FieldPath } from 'firebase-admin/firestore';
import { GetApplicationsService } from '../getApplicationsService';

describe('GetApplicationsService', () => {
  let service: GetApplicationsService;
  let mockFirestore: jest.Mocked<Firestore>;
  let mockCollection: jest.Mock;
  let mockDoc: jest.Mock;
  let mockGet: jest.Mock;
  let mockWhere: jest.Mock;

  beforeEach(() => {
    mockGet = jest.fn();
    mockWhere = jest.fn();
    mockDoc = jest.fn();
    mockCollection = jest.fn();

    mockFirestore = {
      collection: mockCollection,
    } as any;

    service = new GetApplicationsService(mockFirestore);
  });

  describe('execute', () => {
    describe('正常系', () => {
      it('組織にアプリケーションが存在しない場合、空配列を返す', async () => {
        mockGet.mockResolvedValue({
          exists: false,
        });
        mockDoc.mockReturnValue({
          get: mockGet,
        });
        mockCollection.mockReturnValue({
          doc: mockDoc,
        });

        const result = await service.execute('org-123');

        expect(result).toEqual([]);
        expect(mockCollection).toHaveBeenCalledWith('organizations');
        expect(mockDoc).toHaveBeenCalledWith('org-123');
      });

      it('組織のアプリケーションIDリストが空配列の場合、空配列を返す', async () => {
        mockGet.mockResolvedValue({
          exists: true,
          data: () => ({ applications: [] }),
        });
        mockDoc.mockReturnValue({
          get: mockGet,
        });
        mockCollection.mockReturnValue({
          doc: mockDoc,
        });

        const result = await service.execute('org-123');

        expect(result).toEqual([]);
      });

      it('組織のアプリケーションIDリストがnullの場合、空配列を返す', async () => {
        mockGet.mockResolvedValue({
          exists: true,
          data: () => ({ applications: null }),
        });
        mockDoc.mockReturnValue({
          get: mockGet,
        });
        mockCollection.mockReturnValue({
          doc: mockDoc,
        });

        const result = await service.execute('org-123');

        expect(result).toEqual([]);
      });

      it('組織のアプリケーションIDリストがundefinedの場合、空配列を返す', async () => {
        mockGet.mockResolvedValue({
          exists: true,
          data: () => ({}),
        });
        mockDoc.mockReturnValue({
          get: mockGet,
        });
        mockCollection.mockReturnValue({
          doc: mockDoc,
        });

        const result = await service.execute('org-123');

        expect(result).toEqual([]);
      });

      it('アプリケーションが1件の場合、正しく取得できる', async () => {
        const orgDocMock = {
          exists: true,
          data: () => ({ applications: ['app-1'] }),
        };
        const appQueryMock = {
          docs: [
            {
              id: 'app-1',
              data: () => ({ name: 'アプリ1' }),
            },
          ],
        };

        mockGet
          .mockResolvedValueOnce(orgDocMock)
          .mockResolvedValueOnce(appQueryMock);
        mockDoc.mockReturnValue({
          get: mockGet,
        });
        mockWhere.mockReturnValue({
          get: mockGet,
        });
        mockCollection.mockImplementation((name) => {
          if (name === 'organizations') {
            return { doc: mockDoc };
          }
          return { where: mockWhere };
        });

        const result = await service.execute('org-123');

        expect(result).toEqual([
          {
            id: 'app-1',
            name: 'アプリ1',
          },
        ]);
        expect(mockCollection).toHaveBeenCalledWith('applications');
        expect(mockWhere).toHaveBeenCalledWith(FieldPath.documentId(), 'in', ['app-1']);
      });

      it('アプリケーションが10件の場合、1回のクエリで取得できる', async () => {
        const applicationIds = Array.from({ length: 10 }, (_, i) => `app-${i + 1}`);
        const orgDocMock = {
          exists: true,
          data: () => ({ applications: applicationIds }),
        };
        const appQueryMock = {
          docs: applicationIds.map((id, i) => ({
            id,
            data: () => ({ name: `アプリ${i + 1}` }),
          })),
        };

        mockGet
          .mockResolvedValueOnce(orgDocMock)
          .mockResolvedValueOnce(appQueryMock);
        mockDoc.mockReturnValue({
          get: mockGet,
        });
        mockWhere.mockReturnValue({
          get: mockGet,
        });
        mockCollection.mockImplementation((name) => {
          if (name === 'organizations') {
            return { doc: mockDoc };
          }
          return { where: mockWhere };
        });

        const result = await service.execute('org-123');

        expect(result).toHaveLength(10);
        expect(result[0]).toEqual({ id: 'app-1', name: 'アプリ1' });
        expect(result[9]).toEqual({ id: 'app-10', name: 'アプリ10' });
        expect(mockWhere).toHaveBeenCalledTimes(1);
      });

      it('アプリケーションが11件の場合、2回のクエリに分割して取得できる', async () => {
        const applicationIds = Array.from({ length: 11 }, (_, i) => `app-${i + 1}`);
        const orgDocMock = {
          exists: true,
          data: () => ({ applications: applicationIds }),
        };
        const appQueryMock1 = {
          docs: applicationIds.slice(0, 10).map((id, i) => ({
            id,
            data: () => ({ name: `アプリ${i + 1}` }),
          })),
        };
        const appQueryMock2 = {
          docs: [
            {
              id: 'app-11',
              data: () => ({ name: 'アプリ11' }),
            },
          ],
        };

        mockGet
          .mockResolvedValueOnce(orgDocMock)
          .mockResolvedValueOnce(appQueryMock1)
          .mockResolvedValueOnce(appQueryMock2);
        mockDoc.mockReturnValue({
          get: mockGet,
        });
        mockWhere.mockReturnValue({
          get: mockGet,
        });
        mockCollection.mockImplementation((name) => {
          if (name === 'organizations') {
            return { doc: mockDoc };
          }
          return { where: mockWhere };
        });

        const result = await service.execute('org-123');

        expect(result).toHaveLength(11);
        expect(result[0]).toEqual({ id: 'app-1', name: 'アプリ1' });
        expect(result[10]).toEqual({ id: 'app-11', name: 'アプリ11' });
        expect(mockWhere).toHaveBeenCalledTimes(2);
        expect(mockWhere).toHaveBeenNthCalledWith(
          1,
          FieldPath.documentId(),
          'in',
          applicationIds.slice(0, 10)
        );
        expect(mockWhere).toHaveBeenNthCalledWith(
          2,
          FieldPath.documentId(),
          'in',
          applicationIds.slice(10, 11)
        );
      });

      it('アプリケーションが25件の場合、3回のクエリに分割して取得できる', async () => {
        const applicationIds = Array.from({ length: 25 }, (_, i) => `app-${i + 1}`);
        const orgDocMock = {
          exists: true,
          data: () => ({ applications: applicationIds }),
        };
        const appQueryMock1 = {
          docs: applicationIds.slice(0, 10).map((id, i) => ({
            id,
            data: () => ({ name: `アプリ${i + 1}` }),
          })),
        };
        const appQueryMock2 = {
          docs: applicationIds.slice(10, 20).map((id, i) => ({
            id,
            data: () => ({ name: `アプリ${i + 11}` }),
          })),
        };
        const appQueryMock3 = {
          docs: applicationIds.slice(20, 25).map((id, i) => ({
            id,
            data: () => ({ name: `アプリ${i + 21}` }),
          })),
        };

        mockGet
          .mockResolvedValueOnce(orgDocMock)
          .mockResolvedValueOnce(appQueryMock1)
          .mockResolvedValueOnce(appQueryMock2)
          .mockResolvedValueOnce(appQueryMock3);
        mockDoc.mockReturnValue({
          get: mockGet,
        });
        mockWhere.mockReturnValue({
          get: mockGet,
        });
        mockCollection.mockImplementation((name) => {
          if (name === 'organizations') {
            return { doc: mockDoc };
          }
          return { where: mockWhere };
        });

        const result = await service.execute('org-123');

        expect(result).toHaveLength(25);
        expect(result[0]).toEqual({ id: 'app-1', name: 'アプリ1' });
        expect(result[24]).toEqual({ id: 'app-25', name: 'アプリ25' });
        expect(mockWhere).toHaveBeenCalledTimes(3);
      });

      it('Firestoreから取得したアプリケーション情報が正しくマッピングされる', async () => {
        const orgDocMock = {
          exists: true,
          data: () => ({ applications: ['app-1', 'app-2'] }),
        };
        const appQueryMock = {
          docs: [
            {
              id: 'app-1',
              data: () => ({ name: 'テストアプリ1', extraField: 'ignored' }),
            },
            {
              id: 'app-2',
              data: () => ({ name: 'テストアプリ2', anotherField: 'also ignored' }),
            },
          ],
        };

        mockGet
          .mockResolvedValueOnce(orgDocMock)
          .mockResolvedValueOnce(appQueryMock);
        mockDoc.mockReturnValue({
          get: mockGet,
        });
        mockWhere.mockReturnValue({
          get: mockGet,
        });
        mockCollection.mockImplementation((name) => {
          if (name === 'organizations') {
            return { doc: mockDoc };
          }
          return { where: mockWhere };
        });

        const result = await service.execute('org-123');

        expect(result).toEqual([
          { id: 'app-1', name: 'テストアプリ1' },
          { id: 'app-2', name: 'テストアプリ2' },
        ]);
        // extraFieldやanotherFieldは含まれない
        expect(result[0]).not.toHaveProperty('extraField');
        expect(result[1]).not.toHaveProperty('anotherField');
      });
    });
  });
});
